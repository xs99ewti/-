//+------------------------------------------------------------------+
//|                                               EMA + RSI Expert.mq5 |
//|                                                         Dubravaspb |
//|                                                                    |
//+------------------------------------------------------------------+
#property copyright "Dubravaspb"
#property link      ""
#property version   "1.00"
#property description "Created: 2025-02-06 18:24:08"
#property description "Author: Dubravaspb"
#property description "Last Modified: 2025-03-06 13:00:20"
#property description "Modified by: Chupapimunianu"

double OnTester()
{
    // Get basic statistics
    double profit = TesterStatistics(STAT_PROFIT);                     
    double profitable_trades = TesterStatistics(STAT_PROFIT_TRADES);   
    double loss_trades = TesterStatistics(STAT_LOSS_TRADES);          
    double drawdown = TesterStatistics(STAT_BALANCE_DDREL_PERCENT);   
    double sumtrades = TesterStatistics(STAT_TRADES);                 
    double depozit = TesterStatistics(STAT_INITIAL_DEPOSIT);
    double lossposled = TesterStatistics(STAT_MAX_CONLOSS_TRADES);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–æ–ª—å
if(lossposled == 0)
{
    lossposled = 1; // –∏–ª–∏ –¥—Ä—É–≥–æ–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
}
    
    // Store profit sign for later use
    double profit_sign = (profit >= 0) ? 1.0 : -1.0;
    
    // Use absolute profit value for calculations
    profit = MathAbs(profit);
    double totalsum = profit + depozit;
    
    // Initialize penalties
    double tp_sl_penalty = 1.0;
    double win_rate_penalty = 1.0;
    double trade_deficit_penalty = 1.0;
    double trend_penalty = 1.0;
    
    // Calculate win rate
    double whitewin = (sumtrades == 0) ? 0.0 : profitable_trades / sumtrades;
    
    // Set minimum drawdown to 1%
    if(drawdown < 1.1)
        drawdown = 1.0;
    
    // Calculate win/loss ratio
    double win_loss_ratio = (loss_trades == 0) ? profitable_trades : profitable_trades / loss_trades;
    
    // Calculate TP/SL ratio
    double tp = TakeProfit * _Point;
    double sl = StopLoss * _Point;
    double tp_sl_ratio = (sl == 0) ? tp : tp / sl;
    
    // Calculate Sharpe Ratio
    double sharpe_ratio = (drawdown == 0) ? profit : profit / drawdown;
    
    // Apply adaptive TP/SL penalty
    if(tp_sl_ratio < 1.0)
    {
        tp_sl_penalty = 1.0 / tp_sl_ratio * 10.0;  // Higher penalty for TP/SL < 1
    }
    else if(tp_sl_ratio > 5.0)
    {
        tp_sl_penalty = tp_sl_ratio * 10.0;  // Triple penalty for TP/SL > 5
    }
    
    // Apply adaptive win rate penalty
    if(whitewin < 0.5)
    {
        win_rate_penalty = 10.0 / whitewin;
    }
    
    // Apply adaptive trade count penalty
    double minimum_required_trades = 36.0;
    if(sumtrades < minimum_required_trades)
    {
        trade_deficit_penalty = (minimum_required_trades / sumtrades) * 10.0;
    }
    
      
    // Calculate initial criterion
    double criterion = 0;
    if(drawdown != 0)
        criterion = profit * whitewin * profitable_trades / drawdown;
    else
        criterion = profit * whitewin * profitable_trades;
    
    // Apply all penalties
    criterion /= (tp_sl_penalty * win_rate_penalty * trade_deficit_penalty * lossposled);
    
    // Define constants for better readability
double MIN_GROWTH = 1.25;
double MAX_GROWTH = 2.20;

// Apply profit growth check
double profit_growth = pow(totalsum / depozit, 1/1);

if(profit_growth < MIN_GROWTH)
{
    criterion /= (1 + (MIN_GROWTH - profit_growth)) * 10;
}
else if(profit_growth > MAX_GROWTH)
{
    criterion /= (1 + (profit_growth - MAX_GROWTH)) * 10;
}
    
    // Apply trailing stop check
    if(TrailingStopCoef < 0.6)
    {
        criterion /= 1.0;
    }
    
    // Include Sharpe Ratio in final calculation
    criterion *= sharpe_ratio;
    
    // Apply the original profit sign to the final criterion
    criterion *= profit_sign;
    
    // Debug logging
    if(MQLInfoInteger(MQL_DEBUG))
    {
        Print("=== OnTester Enhanced Calculation Details ===");
        Print("Original Profit: ", TesterStatistics(STAT_PROFIT));
        Print("Profit Sign: ", profit_sign);
        Print("Win Rate: ", whitewin);
        Print("Win/Loss Ratio: ", win_loss_ratio);
        Print("TP/SL Ratio: ", tp_sl_ratio);
        Print("TP/SL Penalty: ", tp_sl_penalty);
        Print("Win Rate Penalty: ", win_rate_penalty);
        Print("Trade Deficit Penalty: ", trade_deficit_penalty);
        Print("Trend Penalty: ", trend_penalty);
        Print("Sharpe Ratio: ", sharpe_ratio);
        Print("Drawdown: ", drawdown);
        Print("Total Trades: ", sumtrades);
        Print("Profit Growth: ", profit_growth);
        Print("=== VFI Parameters ===");
        Print("VFI Filter Enabled: ", UseVFIFilter);
        Print("VFI Length: ", VFI_Length);
        Print("VFI Coefficient: ", VFI_Coef);
        Print("VFI Volume Coefficient: ", VFI_VCoef);
        Print("VFI Signal Length: ", VFI_SignalLength);
        Print("VFI Strict Mode: ", VFI_StrictMode);
        Print("VFI Use Real Volume: ", VFI_UseRealVolume);
        Print("=== MACD Parameters ===");
        Print("MACD Filter Enabled: ", UseMACDFilter);
        Print("MACD Fast Length: ", MACD_FastLength);
        Print("MACD Slow Length: ", MACD_SlowLength);
        Print("MACD Signal Length: ", MACD_SignalLength);
        Print("MACD Timeframe: ", EnumToString(MACD_Timeframe));
        Print("MACD Strict Mode: ", MACD_StrictMode);
        Print("MACD Use For Early Close: ", MACD_UseForEarlyClose);
        Print("Final Criterion: ", criterion);
    }
    
    return criterion;
}


#include <Trade\Trade.mqh>
#include <Arrays\ArrayObj.mqh>

// –¢–æ—Ä–≥–æ–≤—ã–π –æ–±—ä–µ–∫—Ç
CTrade trade;

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–æ–≤–æ—Å—Ç–∏
struct SNewsEvent 
{
    datetime time;           // –í—Ä–µ–º—è –Ω–æ–≤–æ—Å—Ç–∏
    string currency;         // –í–∞–ª—é—Ç–∞
    string title;           // –ù–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
    string impact;          // –í–∞–∂–Ω–æ—Å—Ç—å
    string forecast;        // –ü—Ä–æ–≥–Ω–æ–∑
    string previous;        // –ü—Ä–µ–¥—ã–¥—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
};

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –Ω–æ–≤–æ—Å—Ç–Ω–æ–≥–æ —Ñ–∏–ª—å—Ç—Ä–∞
SNewsEvent news[];          // –ú–∞—Å—Å–∏–≤ –Ω–æ–≤–æ—Å—Ç–µ–π
datetime lastUpdate = 0;    // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π
int newsCount = 0;         // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –Ω–æ–≤–æ—Å—Ç–µ–π
datetime nextNewsUpdate;    // –í—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π
string currentNewsFile;     // –¢–µ–∫—É—â–∏–π –∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–π —Ñ–∞–π–ª –Ω–æ–≤–æ—Å—Ç–µ–π

// –û–±—ä—è–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
double initialBalance;
int profitableTrades = 0;
int lossTrades = 0;

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–æ–≤–æ—Å—Ç—è—Ö
input group "=== News Settings ==="
input int UpdateHours = 6;              // –ß–∞—Å–æ–≤ –º–µ–∂–¥—É –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è–º–∏ –Ω–æ–≤–æ—Å—Ç–µ–π
input bool ShowNewsInfo = true;         // –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –Ω–æ–≤–æ—Å—Ç—è—Ö
input color NewsTextColor = clrRed;     // –¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –Ω–æ–≤–æ—Å—Ç–µ–π

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ –¥–Ω—è
input group "=== Mid-Day Break Settings ==="
input bool   UseMidDayBreak = true;          // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ—Ä—ã–≤ –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ –¥–Ω—è
input string MidDayBreakStart = "12:00";     // –í—Ä–µ–º—è –Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ—Ä—ã–≤–∞
input string MidDayBreakEnd = "13:00";       // –í—Ä–µ–º—è –æ–∫–æ–Ω—á–∞–Ω–∏—è –ø–µ—Ä–µ—Ä—ã–≤–∞

// EUR News Settings
input group "=== EUR News Settings ==="
input bool UseEURFilter = true;               // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä EUR –Ω–æ–≤–æ—Å—Ç–µ–π
input bool EUR_NonEconomic = false;           // EUR - –ù–µ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
input bool EUR_Low = false;                   // EUR - –ù–∏–∑–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool EUR_Medium = false;                // EUR - –°—Ä–µ–¥–Ω—è—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool EUR_High = true;                   // EUR - –í—ã—Å–æ–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input int EUR_MinutesBefore = 60;             // EUR - –ú–∏–Ω—É—Ç –¥–æ –Ω–æ–≤–æ—Å—Ç–∏
input int EUR_MinutesAfter = 30;              // EUR - –ú–∏–Ω—É—Ç –ø–æ—Å–ª–µ –Ω–æ–≤–æ—Å—Ç–∏

// USD News Settings
input group "=== USD News Settings ==="
input bool UseUSDFilter = true;               // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä USD –Ω–æ–≤–æ—Å—Ç–µ–π
input bool USD_NonEconomic = false;           // USD - –ù–µ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
input bool USD_Low = false;                   // USD - –ù–∏–∑–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool USD_Medium = false;                // USD - –°—Ä–µ–¥–Ω—è—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool USD_High = true;                   // USD - –í—ã—Å–æ–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input int USD_MinutesBefore = 60;             // USD - –ú–∏–Ω—É—Ç –¥–æ –Ω–æ–≤–æ—Å—Ç–∏
input int USD_MinutesAfter = 91;              // USD - –ú–∏–Ω—É—Ç –ø–æ—Å–ª–µ –Ω–æ–≤–æ—Å—Ç–∏

// GBP News Settings
input group "=== GBP News Settings ==="
input bool UseGBPFilter = true;               // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä GBP –Ω–æ–≤–æ—Å—Ç–µ–π
input bool GBP_NonEconomic = false;           // GBP - –ù–µ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
input bool GBP_Low = false;                   // GBP - –ù–∏–∑–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool GBP_Medium = false;                // GBP - –°—Ä–µ–¥–Ω—è—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool GBP_High = true;                   // GBP - –í—ã—Å–æ–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input int GBP_MinutesBefore = 60;             // GBP - –ú–∏–Ω—É—Ç –¥–æ –Ω–æ–≤–æ—Å—Ç–∏
input int GBP_MinutesAfter = 30;              // GBP - –ú–∏–Ω—É—Ç –ø–æ—Å–ª–µ –Ω–æ–≤–æ—Å—Ç–∏

// JPY News Settings
input group "=== JPY News Settings ==="
input bool UseJPYFilter = true;               // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä JPY –Ω–æ–≤–æ—Å—Ç–µ–π
input bool JPY_NonEconomic = false;           // JPY - –ù–µ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
input bool JPY_Low = false;                   // JPY - –ù–∏–∑–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool JPY_Medium = false;                // JPY - –°—Ä–µ–¥–Ω—è—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool JPY_High = true;                   // JPY - –í—ã—Å–æ–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input int JPY_MinutesBefore = 60;             // JPY - –ú–∏–Ω—É—Ç –¥–æ –Ω–æ–≤–æ—Å—Ç–∏
input int JPY_MinutesAfter = 30;              // JPY - –ú–∏–Ω—É—Ç –ø–æ—Å–ª–µ –Ω–æ–≤–æ—Å—Ç–∏

// CHF News Settings
input group "=== CHF News Settings ==="
input bool UseCHFFilter = true;               // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä CHF –Ω–æ–≤–æ—Å—Ç–µ–π
input bool CHF_NonEconomic = false;           // CHF - –ù–µ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
input bool CHF_Low = false;                   // CHF - –ù–∏–∑–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool CHF_Medium = false;                // CHF - –°—Ä–µ–¥–Ω—è—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool CHF_High = true;                   // CHF - –í—ã—Å–æ–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input int CHF_MinutesBefore = 60;             // CHF - –ú–∏–Ω—É—Ç –¥–æ –Ω–æ–≤–æ—Å—Ç–∏
input int CHF_MinutesAfter = 30;              // CHF - –ú–∏–Ω—É—Ç –ø–æ—Å–ª–µ –Ω–æ–≤–æ—Å—Ç–∏

// AUD News Settings
input group "=== AUD News Settings ==="
input bool UseAUDFilter = true;               // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä AUD –Ω–æ–≤–æ—Å—Ç–µ–π
input bool AUD_NonEconomic = false;           // AUD - –ù–µ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
input bool AUD_Low = false;                   // AUD - –ù–∏–∑–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool AUD_Medium = false;                // AUD - –°—Ä–µ–¥–Ω—è—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool AUD_High = true;                   // AUD - –í—ã—Å–æ–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input int AUD_MinutesBefore = 60;             // AUD - –ú–∏–Ω—É—Ç –¥–æ –Ω–æ–≤–æ—Å—Ç–∏
input int AUD_MinutesAfter = 30;              // AUD - –ú–∏–Ω—É—Ç –ø–æ—Å–ª–µ –Ω–æ–≤–æ—Å—Ç–∏

// CAD News Settings
input group "=== CAD News Settings ==="
input bool UseCADFilter = true;               // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä CAD –Ω–æ–≤–æ—Å—Ç–µ–π
input bool CAD_NonEconomic = false;           // CAD - –ù–µ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
input bool CAD_Low = false;                   // CAD - –ù–∏–∑–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool CAD_Medium = false;                // CAD - –°—Ä–µ–¥–Ω—è—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool CAD_High = true;                   // CAD - –í—ã—Å–æ–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input int CAD_MinutesBefore = 60;             // CAD - –ú–∏–Ω—É—Ç –¥–æ –Ω–æ–≤–æ—Å—Ç–∏
input int CAD_MinutesAfter = 30;              // CAD - –ú–∏–Ω—É—Ç –ø–æ—Å–ª–µ –Ω–æ–≤–æ—Å—Ç–∏

// NZD News Settings
input group "=== NZD News Settings ==="
input bool UseNZDFilter = true;               // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä NZD –Ω–æ–≤–æ—Å—Ç–µ–π
input bool NZD_NonEconomic = false;           // NZD - –ù–µ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
input bool NZD_Low = false;                   // NZD - –ù–∏–∑–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool NZD_Medium = false;                // NZD - –°—Ä–µ–¥–Ω—è—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool NZD_High = true;                   // NZD - –í—ã—Å–æ–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input int NZD_MinutesBefore = 60;             // NZD - –ú–∏–Ω—É—Ç –¥–æ –Ω–æ–≤–æ—Å—Ç–∏
input int NZD_MinutesAfter = 30;              // NZD - –ú–∏–Ω—É—Ç –ø–æ—Å–ª–µ –Ω–æ–≤–æ—Å—Ç–∏

// CNY News Settings
input group "=== CNY News Settings ==="
input bool UseCNYFilter = true;               // –í–∫–ª—é—á–∏—Ç—å —Ñ–∏–ª—å—Ç—Ä CNY –Ω–æ–≤–æ—Å—Ç–µ–π
input bool CNY_NonEconomic = false;           // CNY - –ù–µ—ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏–µ –Ω–æ–≤–æ—Å—Ç–∏
input bool CNY_Low = false;                   // CNY - –ù–∏–∑–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool CNY_Medium = false;                // CNY - –°—Ä–µ–¥–Ω—è—è –≤–∞–∂–Ω–æ—Å—Ç—å
input bool CNY_High = true;                   // CNY - –í—ã—Å–æ–∫–∞—è –≤–∞–∂–Ω–æ—Å—Ç—å
input int CNY_MinutesBefore = 60;             // CNY - –ú–∏–Ω—É—Ç –¥–æ –Ω–æ–≤–æ—Å—Ç–∏
input int CNY_MinutesAfter = 30;              // CNY - –ú–∏–Ω—É—Ç –ø–æ—Å–ª–µ –Ω–æ–≤–æ—Å—Ç–∏

input group "=== News Protection Settings ==="
input bool UseNewsProtectionPlus = true;     // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∑–∞—â–∏—Ç–Ω—ã–π –ø–ª—é—Å –ø—Ä–∏ –Ω–æ–≤–æ—Å—Ç—è—Ö
input int NewsProtectionPlusPoints = 15;     // –ó–∞—â–∏—Ç–Ω—ã–π –ø–ª—é—Å –ø—Ä–∏ –Ω–æ–≤–æ—Å—Ç—è—Ö (–≤ –ø—É–Ω–∫—Ç–∞—Ö)

// –¢–∏–ø—ã —Ü–µ–Ω –¥–ª—è MA
enum ENUM_APPLIED_PRICE_CUSTOM  // –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Ç–∏–ø–æ–≤ —Ü–µ–Ω
{
    PRICE_CLOSE_CUSTOM = PRICE_CLOSE,        // Close
    PRICE_OPEN_CUSTOM = PRICE_OPEN,          // Open
    PRICE_HIGH_CUSTOM = PRICE_HIGH,          // High
    PRICE_LOW_CUSTOM = PRICE_LOW,            // Low
    PRICE_MEDIAN_CUSTOM = PRICE_MEDIAN,      // Median (HL/2)
    PRICE_TYPICAL_CUSTOM = PRICE_TYPICAL,    // Typical (HLC/3)
    PRICE_WEIGHTED_CUSTOM = PRICE_WEIGHTED   // Weighted (HLCC/4)
};
enum TypeOfMA //Type of MA
  {
   AMA,//Adaptive Moving Average
   DEMA,// Double Exponential Moving Average
   FraMA,//Fractal Adaptive Moving Average 
   MA,//Moving Average 
   TEMA,//Triple Exponential Moving Average
   VIDYA,//Variable Index Dynamic Average
   NRMA//Nick Rypock Moving Average
  }; 
enum Smooth_Method //averaging method for NRMA
  {
   MODE_SMA_,  //SMA
   MODE_EMA_,  //EMA
   MODE_SMMA_, //SMMA
   MODE_LWMA_, //LWMA
   MODE_JJMA,  //JJMA
   MODE_JurX,  //JurX
   MODE_ParMA, //ParMA
   MODE_T3,    //T3
   MODE_VIDYA, //VIDYA
   MODE_AMA,   //AMA
  };
enum Applied_price_ //Prices series for NRMA
  {
   PRICE_CLOSE_ = 1,     //close
   PRICE_OPEN_,          //Open
   PRICE_HIGH_,          //High
   PRICE_LOW_,           //Low
   PRICE_MEDIAN_,        //Median Price (HL/2)
   PRICE_TYPICAL_,       //Typical Price (HLC/3)
   PRICE_WEIGHTED_,      //Weighted Close (HLCC/4)
   PRICE_SIMPL_,         //Simpl Price (OC/2)
   PRICE_QUARTER_,       //Quarted Price (HLOC/4) 
   PRICE_TRENDFOLLOW0_,  //TrendFollow_1 Price 
   PRICE_TRENDFOLLOW1_,  //TrendFollow_2 Price
   PRICE_DEMARK_         //Demark Price
  };

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∏—Å–∫–∞–º–∏
input group "=== Risk Management ==="
input double RiskPercent = 1.0;          // –†–∏—Å–∫ –Ω–∞ —Å–¥–µ–ª–∫—É (–≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö)
input bool UseFixedLot = false;          // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ª–æ—Ç
input double FixedLotSize = 0.1;         // –†–∞–∑–º–µ—Ä —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ª–æ—Ç–∞
input double LotReductionPercent = 0.0;  // –ü—Ä–æ—Ü–µ–Ω—Ç —É–º–µ–Ω—å—à–µ–Ω–∏—è –ª–æ—Ç–∞ (0-100)

// Add these new parameters
input group "=== Moving Average Settings ==="
input TypeOfMA Type_MA = AMA;  // Type of Moving Average

// Parameters for AMA
input int AMA_PeriodMA = 14;        // AMA: Period of averaging
input int AMA_PeriodFast = 2;       // AMA: Period of fast EMA
input int AMA_PeriodSlow = 30;      // AMA: Period of slow EMA
input int AMA_Shift = 0;            // AMA: Time shift
input ENUM_APPLIED_PRICE AMA_Applied = PRICE_CLOSE; // AMA: Price type

// Parameters for DEMA
input int DEMA_PeriodMA = 28;       // DEMA: Period of averaging
input int DEMA_Shift = 0;           // DEMA: Time shift
input ENUM_APPLIED_PRICE DEMA_Applied = PRICE_CLOSE; // DEMA: Price type

// Parameters for FraMA
input int FraMA_PeriodMA = 16;      // FraMA: Period of averaging
input int FraMA_Shift = 0;          // FraMA: Time shift
input ENUM_APPLIED_PRICE FraMA_Applied = PRICE_CLOSE; // FraMA: Price type

// Parameters for MA
input int MA_PeriodMA = 15;         // MA: Period of averaging
input int MA_Shift = 0;             // MA: Time shift
input ENUM_MA_METHOD MA_Method = MODE_SMA; // MA: Method
input ENUM_APPLIED_PRICE MA_Applied = PRICE_CLOSE; // MA: Price type

input Smooth_Method      NRMA_Method            =MODE_SMA_;                     //NRMA Method of averaging
input int                XLength                =3;                             //NRMA Depth of smoothing                 
input int                XPhase                 =15;                            //NRMA Parameter of smoothing
input Applied_price_     IPC                    =PRICE_CLOSE_;                  //NRMA Prices series
input double             Kf                     =1;                             //NRMA coefficient of the sliding filter (NRTR)
input double             Fast                   =12;                            //NRMA Factor of smoothing 
input double             Sharp                  =2;                             //NRMA Degree of dynamism of the oscillator
input int                Shift                  =0;                             //NRMA Horizontal shift in bars
input int                PriceShift             =0;                             //NRMA vertical shift in points

// Parameters for TEMA
input int TEMA_PeriodMA = 44;       // TEMA: Period of averaging
input int TEMA_Shift = 0;           // TEMA: Time shift
input ENUM_APPLIED_PRICE TEMA_Applied = PRICE_CLOSE; // TEMA: Price type

// Parameters for VIDYA
input int VIDYA_InpPeriodCMO = 11;  // VIDYA: Period CMO
input int VIDYA_InpPeriodEMA = 27;  // VIDYA: Period EMA
input int VIDYA_InpShift = 0;       // VIDYA: Shift
input ENUM_APPLIED_PRICE VIDYA_Applied = PRICE_CLOSE; // VIDYA: Price type

input int RsiMiddle = 50; // –°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–≤–µ–Ω—å –¥–ª—è RSI

// Growth factor
input double GFactor = 0.0001;      // Growth factor

// Update handles declaration
int MAHandle;        // Single handle for current MA type

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–æ—Ä–≥–æ–≤–ª–∏
input group "=== Trade Parameters ==="
input int StopLoss = 1300;         // –°—Ç–æ–ø –ª–æ—Å—Å (–≤ –ø—É–Ω–∫—Ç–∞—Ö)
input int TakeProfit = 200;        // –¢–µ–π–∫ –ø—Ä–æ—Ñ–∏—Ç (–≤ –ø—É–Ω–∫—Ç–∞—Ö)
input bool UseFixedTP = true;      // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ç–µ–π–∫ –ø—Ä–æ—Ñ–∏—Ç
input bool UseTrailingOrder = true; // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Trailing Order
input int TrailingOrderDistance = 30; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è Trailing Order (–≤ –ø—É–Ω–∫—Ç–∞—Ö)

// –ü–∞—Ä–∞–º–µ—Ç—Ä—ã trailing stop
input group "=== Trailing Stop Parameters ==="
input double TrailingStopCoef = 1.0;    // –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç trailing stop (0 - –æ—Ç–∫–ª—é—á–µ–Ω)

// –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –≤ –Ω–∞—á–∞–ª–æ –∫–æ–¥–∞, –ø–æ—Å–ª–µ –æ–ø–∏—Å–∞–Ω–∏—è –¥—Ä—É–≥–∏—Ö enum
enum ENUM_TRADE_HOURS
{
   H00 = 0,   // 00:00
   H01 = 1,   // 01:00
   H02 = 2,   // 02:00
   H03 = 3,   // 03:00
   H04 = 4,   // 04:00
   H05 = 5,   // 05:00
   H06 = 6,   // 06:00
   H07 = 7,   // 07:00
   H08 = 8,   // 08:00
   H09 = 9,   // 09:00
   H10 = 10,  // 10:00
   H11 = 11,  // 11:00
   H12 = 12,  // 12:00
   H13 = 13,  // 13:00
   H14 = 14,  // 14:00
   H15 = 15,  // 15:00
   H16 = 16,  // 16:00
   H17 = 17,  // 17:00
   H18 = 18,  // 18:00
   H19 = 19,  // 19:00
   H20 = 20,  // 20:00
   H21 = 21,  // 21:00
   H22 = 22,  // 22:00
   H23 = 23   // 23:00
};

// –ó–∞–º–µ–Ω–∏—Ç–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ input –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –≤—Ä–µ–º–µ–Ω–∏ —Ç–æ—Ä–≥–æ–≤–ª–∏ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–µ:
input group "=== Trading Schedule ==="
// –ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫
input bool Monday_Enabled = true;           // –¢–æ—Ä–≥–æ–≤–∞—Ç—å –≤ –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫
input ENUM_TRADE_HOURS Monday_StartHour = H04;    // –ß–∞—Å –Ω–∞—á–∞–ª–∞ (–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫)
input ENUM_TRADE_HOURS Monday_EndHour = H20;      // –ß–∞—Å –æ–∫–æ–Ω—á–∞–Ω–∏—è (–ü–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫)
// –í—Ç–æ—Ä–Ω–∏–∫
input bool Tuesday_Enabled = true;          // –¢–æ—Ä–≥–æ–≤–∞—Ç—å –≤–æ –≤—Ç–æ—Ä–Ω–∏–∫
input ENUM_TRADE_HOURS Tuesday_StartHour = H04;   // –ß–∞—Å –Ω–∞—á–∞–ª–∞ (–í—Ç–æ—Ä–Ω–∏–∫)
input ENUM_TRADE_HOURS Tuesday_EndHour = H20;     // –ß–∞—Å –æ–∫–æ–Ω—á–∞–Ω–∏—è (–í—Ç–æ—Ä–Ω–∏–∫)
// –°—Ä–µ–¥–∞
input bool Wednesday_Enabled = true;        // –¢–æ—Ä–≥–æ–≤–∞—Ç—å –≤ —Å—Ä–µ–¥—É
input ENUM_TRADE_HOURS Wednesday_StartHour = H04; // –ß–∞—Å –Ω–∞—á–∞–ª–∞ (–°—Ä–µ–¥–∞)
input ENUM_TRADE_HOURS Wednesday_EndHour = H20;   // –ß–∞—Å –æ–∫–æ–Ω—á–∞–Ω–∏—è (–°—Ä–µ–¥–∞)
// –ß–µ—Ç–≤–µ—Ä–≥
input bool Thursday_Enabled = true;         // –¢–æ—Ä–≥–æ–≤–∞—Ç—å –≤ —á–µ—Ç–≤–µ—Ä–≥
input ENUM_TRADE_HOURS Thursday_StartHour = H04;  // –ß–∞—Å –Ω–∞—á–∞–ª–∞ (–ß–µ—Ç–≤–µ—Ä–≥)
input ENUM_TRADE_HOURS Thursday_EndHour = H20;    // –ß–∞—Å –æ–∫–æ–Ω—á–∞–Ω–∏—è (–ß–µ—Ç–≤–µ—Ä–≥)
// –ü—è—Ç–Ω–∏—Ü–∞
input bool Friday_Enabled = true;           // –¢–æ—Ä–≥–æ–≤–∞—Ç—å –≤ –ø—è—Ç–Ω–∏—Ü—É
input ENUM_TRADE_HOURS Friday_StartHour = H04;    // –ß–∞—Å –Ω–∞—á–∞–ª–∞ (–ü—è—Ç–Ω–∏—Ü–∞)
input ENUM_TRADE_HOURS Friday_EndHour = H20;      // –ß–∞—Å –æ–∫–æ–Ω—á–∞–Ω–∏—è (–ü—è—Ç–Ω–∏—Ü–∞)

// –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–æ–≤–æ—Å—Ç–µ–π –ø–æ –¥–Ω—è–º –Ω–µ–¥–µ–ª–∏
input group "=== News Check Schedule ==="
input bool Monday_CheckNews = true;        // –ü—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–æ–≤–æ—Å—Ç–∏ –≤ –ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫
input bool Tuesday_CheckNews = true;       // –ü—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–æ–≤–æ—Å—Ç–∏ –≤–æ –≤—Ç–æ—Ä–Ω–∏–∫
input bool Wednesday_CheckNews = true;     // –ü—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–æ–≤–æ—Å—Ç–∏ –≤ —Å—Ä–µ–¥—É
input bool Thursday_CheckNews = true;      // –ü—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–æ–≤–æ—Å—Ç–∏ –≤ —á–µ—Ç–≤–µ—Ä–≥
input bool Friday_CheckNews = true;        // –ü—Ä–æ–≤–µ—Ä—è—Ç—å –Ω–æ–≤–æ—Å—Ç–∏ –≤ –ø—è—Ç–Ω–∏—Ü—É

// Currency Filter Settings
input group "=== Currency Filter Settings ==="
input bool FilterAUD = true;        // Check AUD News
input bool FilterCAD = true;        // Check CAD News
input bool FilterCHF = true;        // Check CHF News
input bool FilterCNY = true;        // Check CNY News
input bool FilterEUR = true;        // Check EUR News
input bool FilterGBP = true;        // Check GBP News
input bool FilterJPY = true;        // Check JPY News
input bool FilterNZD = true;        // Check NZD News
input bool FilterUSD = true;        // Check USD News

// VFI Filter Settings  
input group "=== VFI Filter Settings ==="
input bool UseVFIFilter = true;               // Use VFI filter
input int VFI_Length = 130;                   // VFI period length
input double VFI_Coef = 0.2;                  // VFI coefficient
input double VFI_VCoef = 2.5;                 // VFI volume coefficient (max)
input int VFI_SignalLength = 5;               // VFI signal EMA length
input bool VFI_UseRealVolume = true;          // Use real volume
input bool VFI_StrictMode = false;            // Strict filtering mode (both VFI > EMA AND > 0)

// MACD Filter Settings
input group "=== MACD Filter Settings ==="
input bool UseMACDFilter = false;             // Use MACD filter
input int MACD_FastLength = 12;               // MACD Fast EMA period
input int MACD_SlowLength = 26;               // MACD Slow EMA period
input int MACD_SignalLength = 9;              // MACD Signal SMA period
input ENUM_TIMEFRAMES MACD_Timeframe = PERIOD_CURRENT; // MACD Timeframe
input bool MACD_StrictMode = false;           // Strict filtering mode (MACD > Signal AND histogram condition)
input bool MACD_UseForEarlyClose = false;    // Use MACD for early position closure

// Handles –¥–ª—è –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
int EmaShortHandle;
int EmaLongHandle;
int RsiHandle;
int VFIHandle;                               // VFI indicator handle
int MACDHandle;                              // MACD indicator handle

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
bool isTrailingOrderPlaced = false;
double trailingOrderLot = 0.0;
datetime lastBarTime = 0;
double initialTradePrice = 0;    // –¶–µ–Ω–∞ –ø–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–π —Å–¥–µ–ª–∫–∏
double averageEntryPrice = 0;    // –°—Ä–µ–¥–Ω—è—è —Ü–µ–Ω–∞ –≤—Ö–æ–¥–∞
double initialStopLoss = 0;      // –ù–∞—á–∞–ª—å–Ω—ã–π —Å—Ç–æ–ø-–ª–æ—Å—Å –≤ –ø—É–Ω–∫—Ç–∞—Ö
int totalTrailingOrders = 0;     // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—Ç–∫—Ä—ã—Ç—ã—Ö trailing –æ—Ä–¥–µ—Ä–æ–≤
bool isDayChanged = false;       // –§–ª–∞–≥ —Å–º–µ–Ω—ã –¥–Ω—è
int CurrentTrailingStop = 0;     // –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ trailing stop
int CurrentTrailingStart = 0;    // –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞—á–∞–ª–∞ trailing

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ —Å–≤–µ—á–µ
datetime lastNotificationBuyTime = 0;     // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø–æ–∫—É–ø–∫–µ
datetime lastNotificationSellTime = 0;    // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø—Ä–æ–¥–∞–∂–µ
datetime lastVFICrossingTime = 0;         // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è VFI

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π VFI
double prevVFI = 0;              // –ü—Ä–µ–¥—ã–¥—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ VFI
double prevVFI_EMA = 0;          // –ü—Ä–µ–¥—ã–¥—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ VFI EMA
bool VFI_CrossingInitialized = false;  // –§–ª–∞–≥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π

// ID –æ–±—ä–µ–∫—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–æ–≤–æ—Å—Ç—è—Ö
string newsLabelBase = "NewsInfo_";
int newsLabelsCount = 0;

input bool Check_Single_Currency_News = true;

//+------------------------------------------------------------------+
//| Expert initialization function                                     |
//+------------------------------------------------------------------+
int OnInit()
{
    // Initialize MA handle based on selected type
    switch(Type_MA)
{
    case AMA:
        MAHandle = iAMA(_Symbol, PERIOD_CURRENT, AMA_PeriodMA, AMA_PeriodFast, AMA_PeriodSlow, AMA_Shift, AMA_Applied);
        break;
    case DEMA:
        MAHandle = iDEMA(_Symbol, PERIOD_CURRENT, DEMA_PeriodMA, DEMA_Shift, DEMA_Applied);
        break;
    case FraMA:
        MAHandle = iFrAMA(_Symbol, PERIOD_CURRENT, FraMA_PeriodMA, FraMA_Shift, FraMA_Applied);
        break;
    case MA:
        MAHandle = iMA(_Symbol, PERIOD_CURRENT, MA_PeriodMA, MA_Shift, MA_Method, MA_Applied);
        break;
    case TEMA:
        MAHandle = iTEMA(_Symbol, PERIOD_CURRENT, TEMA_PeriodMA, TEMA_Shift, TEMA_Applied);
        break;
    case VIDYA:
        MAHandle = iVIDyA(_Symbol, PERIOD_CURRENT, VIDYA_InpPeriodCMO, VIDYA_InpPeriodEMA, VIDYA_InpShift, VIDYA_Applied);
        break;
    case NRMA:
        MAHandle = iCustom(_Symbol, PERIOD_CURRENT, "Examples\\nrma", NRMA_Method, XLength, XPhase, IPC, Kf, Fast, Sharp, Shift, PriceShift);
        break;
}

    if(MAHandle == INVALID_HANDLE)
    {
        Print("Error creating MA indicator");
        return(INIT_FAILED);
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞ —Ä–µ–∂–∏–º–æ–≤ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
    if(!CheckTradeParameters())
        return(INIT_FAILED);
    
    // Validate VFI parameters
    if(UseVFIFilter)
    {
        if(VFI_Length <= 0)
        {
            Print("ERROR: VFI_Length must be greater than 0. Current value: ", VFI_Length);
            return(INIT_FAILED);
        }
        if(VFI_SignalLength <= 0)
        {
            Print("ERROR: VFI_SignalLength must be greater than 0. Current value: ", VFI_SignalLength);
            return(INIT_FAILED);
        }
        if(VFI_Coef <= 0)
        {
            Print("ERROR: VFI_Coef must be greater than 0. Current value: ", VFI_Coef);
            return(INIT_FAILED);
        }
        if(VFI_VCoef <= 0)
        {
            Print("ERROR: VFI_VCoef must be greater than 0. Current value: ", VFI_VCoef);
            return(INIT_FAILED);
        }
        
        Print("VFI Filter initialized successfully:");
        Print("- VFI Length: ", VFI_Length);
        Print("- VFI Coefficient: ", VFI_Coef);
        Print("- VFI Volume Coefficient: ", VFI_VCoef);
        Print("- VFI Signal Length: ", VFI_SignalLength);
        Print("- VFI Strict Mode: ", VFI_StrictMode ? "Enabled" : "Disabled");
        Print("- VFI Use Real Volume: ", VFI_UseRealVolume ? "Yes" : "No");
    }
    else
    {
        Print("VFI Filter is disabled");
    }
    
    // Initialize and validate MACD parameters
    if(UseMACDFilter)
    {
        if(MACD_FastLength <= 0 || MACD_SlowLength <= 0 || MACD_SignalLength <= 0)
        {
            Print("ERROR: MACD periods must be greater than 0");
            Print("Fast: ", MACD_FastLength, " Slow: ", MACD_SlowLength, " Signal: ", MACD_SignalLength);
            return(INIT_FAILED);
        }
        if(MACD_FastLength >= MACD_SlowLength)
        {
            Print("ERROR: MACD Fast period must be less than Slow period");
            Print("Fast: ", MACD_FastLength, " Slow: ", MACD_SlowLength);
            return(INIT_FAILED);
        }
        
        // Initialize MACD handle
        MACDHandle = iMACD(_Symbol, MACD_Timeframe, MACD_FastLength, MACD_SlowLength, MACD_SignalLength, PRICE_CLOSE);
        if(MACDHandle == INVALID_HANDLE)
        {
            Print("ERROR: Failed to create MACD indicator");
            return(INIT_FAILED);
        }
        
        Print("MACD Filter initialized successfully:");
        Print("- MACD Fast Length: ", MACD_FastLength);
        Print("- MACD Slow Length: ", MACD_SlowLength);
        Print("- MACD Signal Length: ", MACD_SignalLength);
        Print("- MACD Timeframe: ", EnumToString(MACD_Timeframe));
        Print("- MACD Strict Mode: ", MACD_StrictMode ? "Enabled" : "Disabled");
        Print("- MACD Use For Early Close: ", MACD_UseForEarlyClose ? "Yes" : "No");
    }
    else
    {
        Print("MACD Filter is disabled");
    }
    
    // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Magic Number –¥–ª—è —Ç–æ—Ä–≥–æ–≤—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    trade.SetExpertMagicNumber(123456);
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π VFI
    VFI_CrossingInitialized = false;
    prevVFI = 0;
    prevVFI_EMA = 0;
    lastNotificationBuyTime = 0;
    lastNotificationSellTime = 0;
    lastVFICrossingTime = 0;
    
    Print("VFI Crossing tracking initialized");
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π
    nextNewsUpdate = 0;
    
    // –ü–µ—Ä–≤–æ–Ω–∞—á–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π
    if(ShowNewsInfo)
    {
        UpdateNews(); // –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    }
    
    Print("EA initialized successfully. StopLoss=", StopLoss, " points");
    initialBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    
    // Test VFI calculation if enabled
    if(UseVFIFilter)
    {
        Print("Testing VFI calculation...");
        TestVFICalculation();
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
        Print("Testing VFI crossing detection initialization...");
        int testCrossing = DetectVFICrossing();
        Print("Initial VFI crossing test result: ", testCrossing);
        
        // –ü–æ–ª–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
        Print("Running comprehensive VFI crossing system test...");
        TestVFICrossingSystem();
    }
    
    // Test MACD calculation if enabled
    if(UseMACDFilter)
    {
        Print("Testing MACD calculation...");
        TestMACDCalculation();
    }
    
    return(INIT_SUCCEEDED);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Ñ–∞–π–ª–∞ –Ω–æ–≤–æ—Å—Ç–µ–π –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –º–µ—Å—è—Ü–∞
    if(ShowNewsInfo)
    {
        datetime currentTime = TimeCurrent();
        MqlDateTime dt;
        TimeToStruct(currentTime, dt);
        string filename = StringFormat("news_%04d%02d.txt", dt.year, dt.mon);
        
        if(!FileIsExist(filename))
        {
            Print("Warning: News file not found: ", filename);
            Print("Please make sure news files are in the /Files directory");
        }
        
        if(!UpdateNews())
        {
            Print("Failed to initialize news data");
            return(INIT_FAILED);
        }
    }
    
    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è VFI –∏ –µ–≥–æ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–π –ª–∏–Ω–∏–∏ (EMA)         |
//+------------------------------------------------------------------+
int DetectVFICrossing()
{
    if(!UseVFIFilter) return 0;
    
    double currentVFI = CalculateVFI(0);
    double currentVFI_EMA = GetVFI_EMA(0);
    
    // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
    double previousVFI = CalculateVFI(1);
    double previousVFI_EMA = GetVFI_EMA(1);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö
    if(!ValidateVFIData(currentVFI, currentVFI_EMA, previousVFI, previousVFI_EMA))
    {
        Print("‚ùå VFI Crossing detection aborted due to invalid data");
        return 0; // –ù–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ø—Ä–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    }
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
    if(!VFI_CrossingInitialized)
    {
        prevVFI = previousVFI;
        prevVFI_EMA = previousVFI_EMA;
        VFI_CrossingInitialized = true;
        Print("‚úÖ VFI Crossing tracking initialized with values: VFI=", NormalizeDouble(prevVFI, 4), 
              " EMA=", NormalizeDouble(prevVFI_EMA, 4));
        return 0; // –ù–µ—Ç —Å–∏–≥–Ω–∞–ª–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    }
    
    // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
    if(MQLInfoInteger(MQL_DEBUG))
    {
        Print("üîç VFI Crossing Check:");
        Print("  Current VFI: ", NormalizeDouble(currentVFI, 4));
        Print("  Current EMA: ", NormalizeDouble(currentVFI_EMA, 4));
        Print("  Previous VFI: ", NormalizeDouble(prevVFI, 4));
        Print("  Previous EMA: ", NormalizeDouble(prevVFI_EMA, 4));
    }
    
    int crossingType = 0;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö (–±—ã—á–∏–π —Å–∏–≥–Ω–∞–ª)
    // VFI –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç EMA —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
    if(prevVFI <= prevVFI_EMA && currentVFI > currentVFI_EMA)
    {
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        double crossingStrength = MathAbs(currentVFI - currentVFI_EMA) / MathMax(MathAbs(currentVFI), MathAbs(currentVFI_EMA));
        if(crossingStrength > 0.01) // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–Ω–∞—á–∏–º–æ—Å—Ç—å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è 1%
        {
            crossingType = 1; // –ë—ã—á—å–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ
            Print("üü¢ VFI Bullish Crossing Detected: VFI(", NormalizeDouble(currentVFI, 4), 
                  ") crossed above EMA(", NormalizeDouble(currentVFI_EMA, 4), ") with strength ", 
                  NormalizeDouble(crossingStrength * 100, 2), "%");
        }
        else
        {
            Print("‚ö™ VFI Bullish crossing too weak (strength: ", NormalizeDouble(crossingStrength * 100, 2), "%)");
        }
    }
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –≤–Ω–∏–∑ (–º–µ–¥–≤–µ–∂–∏–π —Å–∏–≥–Ω–∞–ª)  
    // VFI –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç EMA —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
    else if(prevVFI >= prevVFI_EMA && currentVFI < currentVFI_EMA)
    {
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        double crossingStrength = MathAbs(currentVFI - currentVFI_EMA) / MathMax(MathAbs(currentVFI), MathAbs(currentVFI_EMA));
        if(crossingStrength > 0.01) // –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–Ω–∞—á–∏–º–æ—Å—Ç—å –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è 1%
        {
            crossingType = -1; // –ú–µ–¥–≤–µ–∂—å–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ
            Print("üî¥ VFI Bearish Crossing Detected: VFI(", NormalizeDouble(currentVFI, 4), 
                  ") crossed below EMA(", NormalizeDouble(currentVFI_EMA, 4), ") with strength ", 
                  NormalizeDouble(crossingStrength * 100, 2), "%");
        }
        else
        {
            Print("‚ö™ VFI Bearish crossing too weak (strength: ", NormalizeDouble(crossingStrength * 100, 2), "%)");
        }
    }
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –≤—ã–∑–æ–≤–∞
    prevVFI = currentVFI;
    prevVFI_EMA = currentVFI_EMA;
    
    return crossingType;
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ —Å–≤–µ—á–µ                    |
//+------------------------------------------------------------------+
bool ShouldSendNotification(ENUM_ORDER_TYPE orderType)
{
    datetime currentBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);
    
    if(orderType == ORDER_TYPE_BUY)
    {
        if(currentBarTime != lastNotificationBuyTime)
        {
            lastNotificationBuyTime = currentBarTime;
            return true;
        }
    }
    else if(orderType == ORDER_TYPE_SELL)
    {
        if(currentBarTime != lastNotificationSellTime)
        {
            lastNotificationSellTime = currentBarTime;
            return true;
        }
    }
    
    return false; // –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–∞ —ç—Ç–æ–π —Å–≤–µ—á–µ —É–∂–µ –±—ã–ª–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ
}

//+------------------------------------------------------------------+
//| –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö VFI –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –ª–æ–∂–Ω—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤          |
//+------------------------------------------------------------------+
bool ValidateVFIData(double vfi_current, double vfi_ema, double vfi_previous, double vfi_ema_previous)
{
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω—É–ª–µ–≤—ã–µ –∏–ª–∏ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
    if(vfi_current == 0.0 || vfi_ema == 0.0 || vfi_previous == 0.0 || vfi_ema_previous == 0.0)
    {
        Print("‚ö†Ô∏è VFI Validation Failed: Zero values detected");
        return false;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è (–≤–æ–∑–º–æ–∂–Ω–∞—è –æ—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞)
    double maxAllowedValue = 10000.0;
    if(MathAbs(vfi_current) > maxAllowedValue || MathAbs(vfi_ema) > maxAllowedValue ||
       MathAbs(vfi_previous) > maxAllowedValue || MathAbs(vfi_ema_previous) > maxAllowedValue)
    {
        Print("‚ö†Ô∏è VFI Validation Failed: Values too large (>", maxAllowedValue, ")");
        return false;
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–∞–∑—É–º–Ω–æ—Å—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è (–Ω–µ —Å–ª–∏—à–∫–æ–º —Ä–µ–∑–∫–æ–µ)
    double maxChangePercent = 500.0; // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ 500%
    
    if(vfi_previous != 0.0)
    {
        double vfi_change_percent = MathAbs((vfi_current - vfi_previous) / vfi_previous) * 100.0;
        if(vfi_change_percent > maxChangePercent)
        {
            Print("‚ö†Ô∏è VFI Validation Failed: Too rapid VFI change (", NormalizeDouble(vfi_change_percent, 2), "%)");
            return false;
        }
    }
    
    if(vfi_ema_previous != 0.0)
    {
        double ema_change_percent = MathAbs((vfi_ema - vfi_ema_previous) / vfi_ema_previous) * 100.0;
        if(ema_change_percent > maxChangePercent)
        {
            Print("‚ö†Ô∏è VFI Validation Failed: Too rapid EMA change (", NormalizeDouble(ema_change_percent, 2), "%)");
            return false;
        }
    }
    
    return true; // –î–∞–Ω–Ω—ã–µ –≤–∞–ª–∏–¥–Ω—ã
}

//+------------------------------------------------------------------+
//| Calculate VFI (Volume Flow Indicator) value                     |
//+------------------------------------------------------------------+
double CalculateVFI(int index)
{
    // Get required data
    MqlRates rates[];
    ArraySetAsSeries(rates, true);
    
    int copied = CopyRates(_Symbol, PERIOD_CURRENT, index, VFI_Length + 5, rates);
    if(copied < VFI_Length + 2) return 0.0;
    
    double vfi_sum = 0.0;
    
    // Calculate VFI values for the period
    for(int i = 0; i < VFI_Length && i < copied - 1; i++)
    {
        double typical_price = (rates[i].high + rates[i].low + rates[i].close) / 3.0;
        double prev_typical_price = (rates[i+1].high + rates[i+1].low + rates[i+1].close) / 3.0;
        
        double price_change = typical_price - prev_typical_price;
        double volume = VFI_UseRealVolume ? rates[i].real_volume : rates[i].tick_volume;
        
        // Ensure minimum volume
        if(volume <= 0) volume = 1;
        
        // Calculate volume-weighted price change (LazyBear VFI formula)
        double vcp = 0.0;
        if(MathAbs(price_change) > VFI_Coef * _Point)
        {
            double volume_factor = MathMin(volume, VFI_VCoef * volume);
            vcp = (price_change / _Point) * volume_factor;
        }
        
        vfi_sum += vcp;
    }
    
    // Return average VFI value
    return VFI_Length > 0 ? vfi_sum / VFI_Length : 0.0;
}

//+------------------------------------------------------------------+
//| Get VFI EMA value                                               |
//+------------------------------------------------------------------+
double GetVFI_EMA(int index)
{
    static double ema_buffer[];
    static bool initialized = false;
    
    if(!initialized)
    {
        ArraySetAsSeries(ema_buffer, true);
        ArrayResize(ema_buffer, VFI_SignalLength + 50);
        initialized = true;
    }
    
    // Calculate EMA of VFI values
    double alpha = 2.0 / (VFI_SignalLength + 1.0);
    double ema = 0.0;
    
    // Get VFI values for EMA calculation
    for(int i = VFI_SignalLength - 1; i >= 0; i--)
    {
        double vfi_val = CalculateVFI(index + i);
        if(i == VFI_SignalLength - 1)
            ema = vfi_val;
        else
            ema = alpha * vfi_val + (1.0 - alpha) * ema;
    }
    
    return ema;
}

//+------------------------------------------------------------------+
//| Check VFI filter condition with crossing logic                   |
//+------------------------------------------------------------------+
bool CheckVFIFilter(ENUM_ORDER_TYPE orderType)
{
    if(!UseVFIFilter) return true;
    
    // Validate VFI parameters
    if(VFI_Length <= 0 || VFI_SignalLength <= 0 || VFI_Coef <= 0 || VFI_VCoef <= 0)
    {
        Print("ERROR: Invalid VFI parameters. Filter disabled for this signal.");
        return true; // Allow trading if parameters are invalid
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ VFI –∏ EMA
    int crossingType = DetectVFICrossing();
    
    double vfi_current = CalculateVFI(0);
    double vfi_ema = GetVFI_EMA(0);
    
    // Check for invalid values
    if(vfi_current == 0.0 && vfi_ema == 0.0)
    {
        Print("WARNING: VFI calculation returned zero values. Allowing trade.");
        return true; // Allow trading if calculation fails
    }
    
    bool vfi_condition = false;
    
    if(orderType == ORDER_TYPE_BUY)
    {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±—ã—á—å–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ (VFI –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç EMA –≤–≤–µ—Ä—Ö)
        if(crossingType == 1)
        {
            vfi_condition = true;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            if(ShouldSendNotification(ORDER_TYPE_BUY))
            {
                Print("üü¢ VFI Buy Signal: Bullish crossing detected");
            }
        }
        else if(VFI_StrictMode)
        {
            // –í —Å—Ç—Ä–æ–≥–æ–º —Ä–µ–∂–∏–º–µ –±–µ–∑ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è - —Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤–Ω–∞—è
            vfi_condition = (vfi_current > vfi_ema && vfi_current > 0.0);
        }
        else
        {
            // –í –º—è–≥–∫–æ–º —Ä–µ–∂–∏–º–µ –±–µ–∑ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è - —Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤–Ω–∞—è
            vfi_condition = (vfi_current > vfi_ema || vfi_current > 0.0);
        }
    }
    else if(orderType == ORDER_TYPE_SELL)
    {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ–¥–≤–µ–∂—å–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ (VFI –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç EMA –≤–Ω–∏–∑)
        if(crossingType == -1)
        {
            vfi_condition = true;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
            if(ShouldSendNotification(ORDER_TYPE_SELL))
            {
                Print("üî¥ VFI Sell Signal: Bearish crossing detected");
            }
        }
        else if(VFI_StrictMode)
        {
            // –í —Å—Ç—Ä–æ–≥–æ–º —Ä–µ–∂–∏–º–µ –±–µ–∑ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è - —Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤–Ω–∞—è
            vfi_condition = (vfi_current < vfi_ema && vfi_current < 0.0);
        }
        else
        {
            // –í –º—è–≥–∫–æ–º —Ä–µ–∂–∏–º–µ –±–µ–∑ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è - —Å—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –∫–∞–∫ —Ä–µ–∑–µ—Ä–≤–Ω–∞—è
            vfi_condition = (vfi_current < vfi_ema || vfi_current < 0.0);
        }
    }
    
    // Log VFI values for debugging
    if(UseVFIFilter)
    {
        Print("VFI Filter Check - Current: ", NormalizeDouble(vfi_current, 4), 
              " EMA: ", NormalizeDouble(vfi_ema, 4),
              " Crossing: ", crossingType == 1 ? "BULLISH" : (crossingType == -1 ? "BEARISH" : "NONE"),
              " Order: ", EnumToString(orderType),
              " Mode: ", VFI_StrictMode ? "Strict" : "Soft",
              " Condition: ", vfi_condition ? "PASS" : "FAIL");
    }
    
    return vfi_condition;
}

//+------------------------------------------------------------------+
//| Test VFI calculation (for debugging)                            |
//+------------------------------------------------------------------+
void TestVFICalculation()
{
    if(!UseVFIFilter) return;
    
    Print("=== VFI Calculation Test ===");
    
    double vfi_current = CalculateVFI(0);
    double vfi_ema = GetVFI_EMA(0);
    
    Print("VFI Current Value: ", NormalizeDouble(vfi_current, 6));
    Print("VFI EMA Value: ", NormalizeDouble(vfi_ema, 6));
    
    // Test both buy and sell conditions
    bool buy_condition = CheckVFIFilter(ORDER_TYPE_BUY);
    bool sell_condition = CheckVFIFilter(ORDER_TYPE_SELL);
    
    Print("Buy condition: ", buy_condition ? "PASS" : "FAIL");
    Print("Sell condition: ", sell_condition ? "PASS" : "FAIL");
    Print("=== End VFI Test ===");
}

//+------------------------------------------------------------------+
//| Get MACD values (main line, signal line, histogram)             |
//+------------------------------------------------------------------+
bool GetMACDValues(int index, double &macd_main, double &macd_signal, double &macd_histogram)
{
    if(!UseMACDFilter || MACDHandle == INVALID_HANDLE)
        return false;
    
    double macd_buffer[1];
    double signal_buffer[1];
    
    // Get MACD main line
    if(CopyBuffer(MACDHandle, 0, index, 1, macd_buffer) != 1)
        return false;
    
    // Get MACD signal line
    if(CopyBuffer(MACDHandle, 1, index, 1, signal_buffer) != 1)
        return false;
    
    macd_main = macd_buffer[0];
    macd_signal = signal_buffer[0];
    macd_histogram = macd_main - macd_signal;
    
    return true;
}

//+------------------------------------------------------------------+
//| Check MACD filter condition                                     |
//+------------------------------------------------------------------+
bool CheckMACDFilter(ENUM_ORDER_TYPE orderType)
{
    if(!UseMACDFilter) return true;
    
    double macd_current, macd_signal, macd_histogram;
    double macd_prev, macd_signal_prev, macd_histogram_prev;
    
    // Get current MACD values
    if(!GetMACDValues(0, macd_current, macd_signal, macd_histogram))
    {
        Print("WARNING: MACD calculation failed. Allowing trade.");
        return true; // Allow trading if calculation fails
    }
    
    // Get previous MACD values for histogram trend detection
    if(!GetMACDValues(1, macd_prev, macd_signal_prev, macd_histogram_prev))
    {
        Print("WARNING: Previous MACD calculation failed. Using current values only.");
        macd_histogram_prev = macd_histogram;
    }
    
    bool macd_condition = false;
    
    if(orderType == ORDER_TYPE_BUY)
    {
        if(MACD_StrictMode)
        {
            // Strict mode: MACD > Signal AND histogram > 0
            macd_condition = (macd_current > macd_signal && macd_histogram > 0.0);
        }
        else
        {
            // Soft mode: MACD > Signal OR histogram growing
            bool histogram_growing = (macd_histogram > macd_histogram_prev);
            macd_condition = (macd_current > macd_signal || histogram_growing);
        }
    }
    else if(orderType == ORDER_TYPE_SELL)
    {
        if(MACD_StrictMode)
        {
            // Strict mode: MACD < Signal AND histogram < 0
            macd_condition = (macd_current < macd_signal && macd_histogram < 0.0);
        }
        else
        {
            // Soft mode: MACD < Signal OR histogram falling
            bool histogram_falling = (macd_histogram < macd_histogram_prev);
            macd_condition = (macd_current < macd_signal || histogram_falling);
        }
    }
    
    // Log MACD values for debugging
    if(UseMACDFilter)
    {
        Print("MACD Filter Check - Main: ", NormalizeDouble(macd_current, 6), 
              " Signal: ", NormalizeDouble(macd_signal, 6),
              " Histogram: ", NormalizeDouble(macd_histogram, 6),
              " Hist Prev: ", NormalizeDouble(macd_histogram_prev, 6),
              " Order: ", EnumToString(orderType),
              " Mode: ", MACD_StrictMode ? "Strict" : "Soft",
              " Condition: ", macd_condition ? "PASS" : "FAIL");
    }
    
    return macd_condition;
}

//+------------------------------------------------------------------+
//| Test MACD calculation (for debugging)                           |
//+------------------------------------------------------------------+
void TestMACDCalculation()
{
    if(!UseMACDFilter) return;
    
    Print("=== MACD Calculation Test ===");
    
    double macd_main, macd_signal, macd_histogram;
    if(GetMACDValues(0, macd_main, macd_signal, macd_histogram))
    {
        Print("MACD Main Value: ", NormalizeDouble(macd_main, 6));
        Print("MACD Signal Value: ", NormalizeDouble(macd_signal, 6));
        Print("MACD Histogram Value: ", NormalizeDouble(macd_histogram, 6));
        
        // Test both buy and sell conditions
        bool buy_condition = CheckMACDFilter(ORDER_TYPE_BUY);
        bool sell_condition = CheckMACDFilter(ORDER_TYPE_SELL);
        
        Print("Buy condition: ", buy_condition ? "PASS" : "FAIL");
        Print("Sell condition: ", sell_condition ? "PASS" : "FAIL");
    }
    else
    {
        Print("ERROR: Failed to get MACD values");
    }
    Print("=== End MACD Test ===");
}

//+------------------------------------------------------------------+
//| –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π VFI                             |
//+------------------------------------------------------------------+
void TestVFICrossingSystem()
{
    if(!UseVFIFilter)
    {
        Print("VFI Filter disabled - skipping crossing system test");
        return;
    }
    
    Print("=== VFI CROSSING SYSTEM TEST ===");
    
    // –¢–µ—Å—Ç 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö
    Print("Test 1: Data validation");
    bool validationTest1 = ValidateVFIData(100.0, 50.0, 90.0, 45.0);  // –ù–æ—Ä–º–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
    bool validationTest2 = ValidateVFIData(0.0, 50.0, 90.0, 45.0);    // –ù—É–ª–µ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    bool validationTest3 = ValidateVFIData(15000.0, 50.0, 90.0, 45.0); // –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    
    Print("  Normal data validation: ", validationTest1 ? "PASS" : "FAIL");
    Print("  Zero data validation: ", validationTest2 ? "FAIL (unexpected)" : "PASS");
    Print("  Large data validation: ", validationTest3 ? "FAIL (unexpected)" : "PASS");
    
    // –¢–µ—Å—Ç 2: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ—É–Ω–∫—Ü–∏–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
    Print("Test 2: Notification system");
    datetime testTime = TimeCurrent();
    bool notifyTest1 = ShouldSendNotification(ORDER_TYPE_BUY);   // –ü–µ—Ä–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    bool notifyTest2 = ShouldSendNotification(ORDER_TYPE_BUY);   // –ü–æ–≤—Ç–æ—Ä–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –Ω–∞ —Ç–æ–π –∂–µ —Å–≤–µ—á–µ
    
    Print("  First buy notification: ", notifyTest1 ? "PASS" : "FAIL");
    Print("  Duplicate buy notification: ", notifyTest2 ? "FAIL (unexpected)" : "PASS");
    
    // –¢–µ—Å—Ç 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
    Print("Test 3: Crossing detection initialization");
    bool initBefore = VFI_CrossingInitialized;
    int crossingResult = DetectVFICrossing();
    bool initAfter = VFI_CrossingInitialized;
    
    Print("  Initialized before: ", initBefore ? "YES" : "NO");
    Print("  Initialized after: ", initAfter ? "YES" : "NO");
    Print("  Initial crossing result: ", crossingResult);
    
    // –¢–µ—Å—Ç 4: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–µ–∫—É—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π VFI
    Print("Test 4: Current VFI values");
    double currentVFI = CalculateVFI(0);
    double currentEMA = GetVFI_EMA(0);
    
    Print("  Current VFI: ", NormalizeDouble(currentVFI, 4));
    Print("  Current EMA: ", NormalizeDouble(currentEMA, 4));
    Print("  VFI > EMA: ", currentVFI > currentEMA ? "YES" : "NO");
    
    // –¢–µ—Å—Ç 5: –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∏–ª—å—Ç—Ä–∞ –¥–ª—è –æ–±–µ–∏—Ö –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
    Print("Test 5: Filter conditions");
    bool buyFilter = CheckVFIFilter(ORDER_TYPE_BUY);
    bool sellFilter = CheckVFIFilter(ORDER_TYPE_SELL);
    
    Print("  Buy filter result: ", buyFilter ? "PASS" : "FAIL");
    Print("  Sell filter result: ", sellFilter ? "PASS" : "FAIL");
    
    Print("=== VFI CROSSING SYSTEM TEST COMPLETED ===");
}

//+------------------------------------------------------------------+
//| –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π VFI (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–π —Ç–∏–∫)  |
//+------------------------------------------------------------------+
void UpdateVFICrossing()
{
    if(!UseVFIFilter) return;
    
    // –ó–∞—â–∏—Ç–∞ –æ—Ç –æ—à–∏–±–æ–∫ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏ –±–∞—Ä–∞
    datetime currentBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);
    if(currentBarTime <= 0)
    {
        Print("‚ö†Ô∏è UpdateVFICrossing: Invalid bar time, skipping update");
        return;
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π —Ç–æ–ª—å–∫–æ –Ω–∞ –Ω–æ–≤–æ–º –±–∞—Ä–µ
    if(currentBarTime != lastVFICrossingTime)
    {
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –ø—Ä–∏ —Å–º–µ–Ω–µ –±–∞—Ä–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω–æ–≤—ã–π –±–∞—Ä
        if(lastVFICrossingTime != 0) // –ù–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ
        {
            // –ü—Ä–∏ —Å–º–µ–Ω–µ –±–∞—Ä–∞ —Ä–∞–∑—Ä–µ—à–∞–µ–º –Ω–æ–≤—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            Print("üìä New bar detected, VFI crossing notifications reset for bar: ", TimeToString(currentBarTime));
        }
        
        lastVFICrossingTime = currentBarTime;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –Ω–∞ –∫–∞–∂–¥–æ–º –Ω–æ–≤–æ–º –±–∞—Ä–µ
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º try-catch –∞–Ω–∞–ª–æ–≥ —á–µ—Ä–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        int crossingResult = DetectVFICrossing();
        
        if(crossingResult != 0)
        {
            Print("üéØ VFI Crossing detected on new bar: ", 
                  crossingResult == 1 ? "BULLISH" : "BEARISH", 
                  " at ", TimeToString(currentBarTime));
        }
    }
    
    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –æ—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –∫–∞–∂–¥—ã–π —Ç–∏–∫ (—Ç–æ–ª—å–∫–æ –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏)
    if(MQLInfoInteger(MQL_DEBUG))
    {
        static datetime lastDebugTime = 0;
        datetime currentTime = TimeCurrent();
        
        // –í—ã–≤–æ–¥–∏–º –æ—Ç–ª–∞–¥–æ—á–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –Ω–µ —á–∞—â–µ —Ä–∞–∑–∞ –≤ –º–∏–Ω—É—Ç—É
        if(currentTime - lastDebugTime >= 60)
        {
            // –ó–∞—â–∏—â–µ–Ω–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π VFI
            double currentVFI = CalculateVFI(0);
            double currentVFI_EMA = GetVFI_EMA(0);
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–Ω–æ—Å—Ç—å –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π
            if(currentVFI != 0.0 || currentVFI_EMA != 0.0)
            {
                Print("üîç VFI Debug Info:");
                Print("  Current VFI: ", NormalizeDouble(currentVFI, 4));
                Print("  Current EMA: ", NormalizeDouble(currentVFI_EMA, 4));
                Print("  VFI > EMA: ", currentVFI > currentVFI_EMA ? "YES" : "NO");
                Print("  Last crossing time: ", TimeToString(lastVFICrossingTime));
                Print("  Crossing initialized: ", VFI_CrossingInitialized ? "YES" : "NO");
            }
            else
            {
                Print("‚ö†Ô∏è VFI Debug: Invalid VFI values detected");
            }
            
            lastDebugTime = currentTime;
        }
    }
}
//+------------------------------------------------------------------+
//| –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–∏—Å—Ç–µ–º—ã –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π VFI                        |
//+------------------------------------------------------------------+
void PrintVFICrossingStatus()
{
    if(!UseVFIFilter)
    {
        Print("VFI Filter is disabled");
        return;
    }
    
    Print("‚ïê‚ïê‚ïê VFI CROSSING SYSTEM STATUS ‚ïê‚ïê‚ïê");
    Print("Initialized: ", VFI_CrossingInitialized ? "YES" : "NO");
    Print("Last crossing bar time: ", TimeToString(lastVFICrossingTime));
    Print("Last buy notification: ", TimeToString(lastNotificationBuyTime));
    Print("Last sell notification: ", TimeToString(lastNotificationSellTime));
    
    if(VFI_CrossingInitialized)
    {
        double currentVFI = CalculateVFI(0);
        double currentEMA = GetVFI_EMA(0);
        
        Print("Current VFI: ", NormalizeDouble(currentVFI, 4));
        Print("Current EMA: ", NormalizeDouble(currentEMA, 4));
        Print("Stored prev VFI: ", NormalizeDouble(prevVFI, 4));
        Print("Stored prev EMA: ", NormalizeDouble(prevVFI_EMA, 4));
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        string currentState = "UNKNOWN";
        if(currentVFI > currentEMA)
            currentState = "VFI ABOVE EMA";
        else if(currentVFI < currentEMA)
            currentState = "VFI BELOW EMA";
        else
            currentState = "VFI EQUALS EMA";
            
        Print("Current state: ", currentState);
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
        if(prevVFI != 0 && prevVFI_EMA != 0)
        {
            string potentialCrossing = "NONE";
            if(prevVFI <= prevVFI_EMA && currentVFI > currentEMA)
                potentialCrossing = "BULLISH CROSSING OCCURRED";
            else if(prevVFI >= prevVFI_EMA && currentVFI < currentEMA)
                potentialCrossing = "BEARISH CROSSING OCCURRED";
            else if(prevVFI < prevVFI_EMA && currentVFI < currentEMA)
                potentialCrossing = "POTENTIAL BULLISH SETUP";
            else if(prevVFI > prevVFI_EMA && currentVFI > currentEMA)
                potentialCrossing = "POTENTIAL BEARISH SETUP";
                
            Print("Crossing status: ", potentialCrossing);
        }
    }
    Print("‚ïê‚ïê‚ïê END VFI CROSSING STATUS ‚ïê‚ïê‚ïê");
}

    
void CheckForOpen()
{
    MqlRates rt[2];
    double ma[2];
    if(CopyRates(_Symbol, PERIOD_CURRENT, 0, 2, rt) != 2) return;
    if(CopyBuffer(MAHandle, 0, 0, 2, ma) != 2) return;

    static bool SellCross = false;
    static bool BuyCross = false;
    ENUM_ORDER_TYPE signal = WRONG_VALUE;
    // –ú–µ–¥–≤–µ–∂–∏–π –∫—Ä–µ—Å—Ç: —Ç–µ–ª–æ —Å–≤–µ—á–∏ –≤–Ω–∏–∑ —á–µ—Ä–µ–∑ MA
    if(rt[0].open > ma[0] && rt[0].close < ma[0]) {
        if(BuyCross) BuyCross = false;
        SellCross = true;
    }
    // –ë—ã—á–∏–π –∫—Ä–µ—Å—Ç: —Ç–µ–ª–æ —Å–≤–µ—á–∏ –≤–≤–µ—Ä—Ö —á–µ—Ä–µ–∑ MA
    else if(rt[0].open < ma[0] && rt[0].close > ma[0]) {
        if(SellCross) SellCross = false;
        BuyCross = true;
    }
    // –£—Å–ª–æ–≤–∏–µ –Ω–∞ –ø—Ä–æ–¥–∞–∂—É
    if(SellCross && ma[0] > ma[1] && ma[0]-ma[1] > GFactor) {
        signal = ORDER_TYPE_SELL;
        SellCross = false;
    }
    // –£—Å–ª–æ–≤–∏–µ –Ω–∞ –ø–æ–∫—É–ø–∫—É
    else if(BuyCross && ma[1] > ma[0] && ma[1]-ma[0] > GFactor) {
        signal = ORDER_TYPE_BUY;
        BuyCross = false;
    }

    if(signal != WRONG_VALUE) {
        // Check VFI filter before opening position
        if(CheckVFIFilter(signal))
        {
            // Check MACD filter if enabled
            if(CheckMACDFilter(signal))
            {
                OpenPosition(signal);
            }
            else
            {
                Print("Trade signal filtered out by MACD: ", EnumToString(signal));
            }
        }
        else
        {
            Print("Trade signal filtered out by VFI: ", EnumToString(signal));
        }
    }
}

void CheckForClose()
{
    MqlRates rt[2];
    double ma[1];
    if(CopyRates(_Symbol, PERIOD_CURRENT, 0, 2, rt) != 2) return;
    if(CopyBuffer(MAHandle, 0, 0, 1, ma) != 1) return;

    long type = PositionGetInteger(POSITION_TYPE);
    bool signal = false;

    if(type == POSITION_TYPE_BUY && rt[0].open > ma[0] && rt[0].close < ma[0])
        signal = true;
    if(type == POSITION_TYPE_SELL && rt[0].open < ma[0] && rt[0].close > ma[0])
        signal = true;

    // Check MACD for early closure if enabled
    if(!signal && MACD_UseForEarlyClose)
    {
        if(type == POSITION_TYPE_BUY)
        {
            // Close buy position if MACD shows bearish signal
            if(!CheckMACDFilter(ORDER_TYPE_BUY))
            {
                signal = true;
                Print("Early closure triggered by MACD for BUY position");
            }
        }
        else if(type == POSITION_TYPE_SELL)
        {
            // Close sell position if MACD shows bullish signal
            if(!CheckMACDFilter(ORDER_TYPE_SELL))
            {
                signal = true;
                Print("Early closure triggered by MACD for SELL position");
            }
        }
    }

    if(signal)
        trade.PositionClose(_Symbol, 3);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                   |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
    // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º —Ö—ç–Ω–¥–ª—ã –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤
    IndicatorRelease(EmaShortHandle);
    IndicatorRelease(EmaLongHandle);
    IndicatorRelease(RsiHandle);
    IndicatorRelease(MAHandle);
    if(UseMACDFilter && MACDHandle != INVALID_HANDLE)
        IndicatorRelease(MACDHandle);
    
    // –£–¥–∞–ª—è–µ–º –≤—Å–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–µ –º–µ—Ç–∫–∏
    DeleteNewsLabels();
    
    Print("EA deinitialized with reason code: ", reason);
}

//+------------------------------------------------------------------+
//| Expert tick function                                              |
//+------------------------------------------------------------------+
void OnTick()
{
    static datetime lastDayTime = 0;
    datetime currentTime = TimeCurrent();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–æ–≤–æ—Å—Ç–∏ –∫–∞–∂–¥—ã–µ UpdateHours —á–∞—Å–æ–≤
    if(ShowNewsInfo && currentTime >= nextNewsUpdate)
    {
        UpdateNews();
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–º–µ–Ω—É –¥–Ω—è
    MqlDateTime current;
    TimeToStruct(currentTime, current);
    
    if(lastDayTime == 0)
    {
        lastDayTime = currentTime;
        PrintFormat("EA started on %d-%02d-%02d", current.year, current.mon, current.day);
    }
    else
    {
        MqlDateTime last;
        TimeToStruct(lastDayTime, last);
        
        if(current.day != last.day)
        {
            lastDayTime = currentTime;
            isDayChanged = true;
            PrintFormat("New trading day detected: %d-%02d-%02d", current.year, current.mon, current.day);
        }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –Ω–æ–≤–æ—Å—Ç–∏ –∫–∞–∂–¥—ã–µ UpdateHours —á–∞—Å–æ–≤
    if(ShowNewsInfo && currentTime >= nextNewsUpdate)
    {
        UpdateNews();
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π
    bool hasOpenPositions = false;
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
               PositionGetInteger(POSITION_MAGIC) == 123456)
            {
                hasOpenPositions = true;
                break;
            }
        }
    }

    // –ï—Å–ª–∏ –µ—Å—Ç—å –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∏—Ö –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –≤—Ä–µ–º–µ–Ω–∏
    if(hasOpenPositions)
    {
        UpdateTrailingStop();
        
        if(UseTrailingOrder)
            CheckTrailingOrder();
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ—Ä–≥–æ–≤–æ–µ –≤—Ä–µ–º—è –∏ –Ω–∞–ª–∏—á–∏–µ –≤–∞–∂–Ω—ã—Ö –Ω–æ–≤–æ—Å—Ç–µ–π
    if(!IsTradeTime() || IsNewsTime())
    {
        if(IsNewsTime())
            Print("Trading paused due to upcoming/active news");
        return;
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π VFI
    UpdateVFICrossing();

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π –Ω–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
    if(!HasNewsForCurrentDay())
    {
        return;
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–µ–∫—É—â–µ–º –±–∞—Ä–µ
    datetime currentBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);
    bool isNewBar = (currentBarTime != lastBarTime);
    MqlDateTime barTime;
    TimeToStruct(currentBarTime, barTime);
    bool isBarStart = (currentTime - currentBarTime) < 60;
    
    if(isNewBar && isBarStart)
{
    if(hasOpenPositions)
        CheckForClose();
    else
        CheckForOpen();
    lastBarTime = currentBarTime;
}
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–æ–≤–æ—Å—Ç—è—Ö
    if(ShowNewsInfo)
        UpdateNewsDisplay();
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Ä—ã–≤–∞ –≤ —Å–µ—Ä–µ–¥–∏–Ω–µ –¥–Ω—è                                  |
//+------------------------------------------------------------------+
bool IsMidDayBreak()
{
    if(!UseMidDayBreak)
        return false;
        
    if(!CheckTimeString(MidDayBreakStart) || !CheckTimeString(MidDayBreakEnd))
    {
        Print("Invalid mid-day break time format");
        return false;
    }
    
    datetime currentTime = TimeCurrent();
    string currentDate = TimeToString(currentTime, TIME_DATE);
    
    datetime breakStart = StringToTime(currentDate + " " + MidDayBreakStart);
    datetime breakEnd = StringToTime(currentDate + " " + MidDayBreakEnd);
    
    return (currentTime >= breakStart && currentTime <= breakEnd);
}

//+------------------------------------------------------------------+
//| –†–∞—Å—á–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞ —Å —É—á–µ—Ç–æ–º –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π              |
//+------------------------------------------------------------------+
double CalculateAvailableBalance()
{
    double accountEquity = AccountInfoDouble(ACCOUNT_BALANCE);
    double potentialLoss = 0;
    
    // –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ —É–±—ã—Ç–∫–∏ –ø–æ –≤—Å–µ–º –æ—Ç–∫—Ä—ã—Ç—ã–º –ø–æ–∑–∏—Ü–∏—è–º
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
               PositionGetInteger(POSITION_MAGIC) == 123456)
            {
                double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                double stopLoss = PositionGetDouble(POSITION_SL);
                double lotSize = PositionGetDouble(POSITION_VOLUME);
                ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                
                // –ï—Å–ª–∏ —Å—Ç–æ–ø-–ª–æ—Å—Å –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –≤–æ–∑–º–æ–∂–Ω—ã–π —É–±—ã—Ç–æ–∫
                if(stopLoss == 0)
                {
                    {
                        stopLoss = (posType == POSITION_TYPE_BUY) ? 
                                  openPrice - (StopLoss * _Point) :
                                  openPrice + (StopLoss * _Point);
                    }
                }
                
                // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–π —É–±—ã—Ç–æ–∫
                double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
                double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
                double pointsToLoss = MathAbs(openPrice - stopLoss) / _Point;
                double potentialPositionLoss = (pointsToLoss * _Point / tickSize) * tickValue * lotSize;
                
                potentialLoss += potentialPositionLoss;
            }
        }
    }
    
    // –í—ã—á–∏—Ç–∞–µ–º –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ —É–±—ã—Ç–∫–∏ –∏–∑ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞
    return accountEquity - potentialLoss;
}

//+------------------------------------------------------------------+
//| –†–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ –ª–æ—Ç–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∏—Å–∫–∞                               |
//+------------------------------------------------------------------+
double CalculateLotSize(double stopLossPoints)
{
    datetime currentTime = TimeCurrent();
    string logHeader = StringFormat("\n=== LOT CALCULATION [%s] ===\n", TimeToString(currentTime));
    string logMessage = logHeader;
    
    // –ü–æ–ª—É—á–∞–µ–º –±–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å–∏–º–≤–æ–ª–∞
    double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    
    logMessage += StringFormat("Symbol: %s\n", _Symbol);
    logMessage += StringFormat("Tick Size: %.6f\n", tickSize);
    logMessage += StringFormat("Tick Value: %.6f\n", tickValue);
    logMessage += StringFormat("Lot Step: %.6f\n", lotStep);
    logMessage += StringFormat("Min Lot: %.6f\n", minLot);
    logMessage += StringFormat("Max Lot: %.6f\n", maxLot);
    
    // –ï—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ª–æ—Ç
    if(UseFixedLot) 
    {
        double reducedLot = FixedLotSize * (1 - LotReductionPercent/100);
        reducedLot = NormalizeDouble(reducedLot, 2);
        
        logMessage += StringFormat("Using Fixed Lot Size: %.2f (Reduced by %.2f%% to %.2f)\n",
                                 FixedLotSize, LotReductionPercent, reducedLot);
        Print(logMessage);
        return reducedLot;
    }
    
    // –†–∞—Å—á–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∏—Å–∫–∞
    double availableEquity = CalculateAvailableBalance();
    double riskAmount = availableEquity * RiskPercent / 100;
    
    logMessage += StringFormat("Available Equity: %.2f\n", availableEquity);
    logMessage += StringFormat("Risk Percent: %.2f%%\n", RiskPercent);
    logMessage += StringFormat("Risk Amount: %.2f\n", riskAmount);
    logMessage += StringFormat("Stop Loss Points: %.2f\n", stopLossPoints);
    
    // –†–∞—Å—á–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –æ–¥–Ω–æ–≥–æ –ø—É–Ω–∫—Ç–∞
    double pointCost = tickValue * (stopLossPoints * _Point / tickSize);
    logMessage += StringFormat("Point Cost: %.6f\n", pointCost);
    
    // –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π —Ä–∞—Å—á–µ—Ç –ª–æ—Ç–∞
    double lot = NormalizeDouble(riskAmount / (pointCost * (1/lotStep)), 2);
    logMessage += StringFormat("Preliminary Lot: %.2f\n", lot);
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º —É–º–µ–Ω—å—à–µ–Ω–∏–µ –ª–æ—Ç–∞
    lot = lot * (1 - LotReductionPercent/100);
    logMessage += StringFormat("After Reduction (%.2f%%): %.2f\n", 
                             LotReductionPercent, lot);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π/–º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –ª–æ—Ç–∞
    if(lot < minLot) 
    {
        lot = minLot;
        logMessage += "WARNING: Adjusted to minimum lot size\n";
    }
    if(lot > maxLot * 500000) 
    {
        lot = maxLot * 500000;
        logMessage += "WARNING: Adjusted to maximum allowed lot size\n";
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞—Ä–∂–∏–Ω–∞–ª—å–Ω—ã—Ö —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π
    double marginRequired = 0.0;
    if(OrderCalcMargin(ORDER_TYPE_BUY, _Symbol, lot, SymbolInfoDouble(_Symbol, SYMBOL_ASK), marginRequired))
    {
        double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
        logMessage += StringFormat("Margin Required: %.2f\n", marginRequired);
        logMessage += StringFormat("Free Margin: %.2f\n", freeMargin);
        
        if(marginRequired > freeMargin)
        {
            double maxPossibleLots = (freeMargin / marginRequired) * lot * 0.95;
            lot = NormalizeDouble(maxPossibleLots, 2);
            logMessage += StringFormat("WARNING: Lot adjusted due to margin requirements to %.2f\n", lot);
        }
    }
    
    // –û–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–∞—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
    lot = NormalizeDouble(lot, 2);
    logMessage += StringFormat("Final Lot Size: %.2f\n", lot);
    
    Print(logMessage);
    return lot;
}
//+------------------------------------------------------------------+
//| –û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏                                                   |
//+------------------------------------------------------------------+
void OpenPosition(ENUM_ORDER_TYPE orderType)
{
    string logMessage = StringFormat("\n=== POSITION OPENING [%s] ===\n", TimeToString(TimeCurrent()));
    
    // Add VFI information to log
    if(UseVFIFilter)
    {
        double vfi_current = CalculateVFI(0);
        double vfi_ema = GetVFI_EMA(0);
        logMessage += StringFormat("VFI Current: %.4f\n", vfi_current);
        logMessage += StringFormat("VFI EMA: %.4f\n", vfi_ema);
        logMessage += StringFormat("VFI Filter Mode: %s\n", VFI_StrictMode ? "Strict" : "Soft");
    }
    
    // Add MACD information to log
    if(UseMACDFilter)
    {
        double macd_main, macd_signal, macd_histogram;
        if(GetMACDValues(0, macd_main, macd_signal, macd_histogram))
        {
            logMessage += StringFormat("MACD Main: %.6f\n", macd_main);
            logMessage += StringFormat("MACD Signal: %.6f\n", macd_signal);
            logMessage += StringFormat("MACD Histogram: %.6f\n", macd_histogram);
            logMessage += StringFormat("MACD Filter Mode: %s\n", MACD_StrictMode ? "Strict" : "Soft");
        }
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—á–µ—Ç–µ
    double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
    
    logMessage += StringFormat("Account Balance: %.2f\n", accountBalance);
    logMessage += StringFormat("Free Margin: %.2f\n", freeMargin);
    
    // –†–∞—Å—á–µ—Ç —Ä–∞–∑–º–µ—Ä–∞ –ª–æ—Ç–∞
    double lotSize = CalculateLotSize(StopLoss);
    
    logMessage += StringFormat("Calculated Lot Size: %.2f\n", lotSize);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ —Ä–∞–∑–º–µ—Ä–∞ –ª–æ—Ç–∞
    if(lotSize <= 0 || lotSize < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN))
    {
        Print(logMessage + "ERROR: Invalid lot size calculated");
        return;
    }
    
    // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ —Ü–µ–Ω—ã
    double askPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
    double bidPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double openPrice = (orderType == ORDER_TYPE_BUY) ? askPrice : bidPrice;
    
    logMessage += StringFormat("Ask Price: %.5f\n", askPrice);
    logMessage += StringFormat("Bid Price: %.5f\n", bidPrice);
    logMessage += StringFormat("Open Price: %.5f\n", openPrice);
    
    // –†–∞—Å—á–µ—Ç —É—Ä–æ–≤–Ω–µ–π Stop Loss –∏ Take Profit
    double stopLoss, takeProfit;
    
    if(orderType == ORDER_TYPE_BUY)
    {
        stopLoss = openPrice - StopLoss * _Point;
        takeProfit = UseFixedTP ? openPrice + TakeProfit * _Point 
                               : openPrice + (StopLoss * 2) * _Point;
    }
    else
    {
        stopLoss = openPrice + StopLoss * _Point;
        takeProfit = UseFixedTP ? openPrice - TakeProfit * _Point 
                               : openPrice - (StopLoss * 2) * _Point;
    }
    
    logMessage += StringFormat("Stop Loss: %.5f\n", stopLoss);
    logMessage += StringFormat("Take Profit: %.5f\n", takeProfit);
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∞—Ä–∂–∏–Ω–∞–ª—å–Ω—ã—Ö —Ç—Ä–µ–±–æ–≤–∞–Ω–∏–π
    double marginRequired = 0.0;
    if(!OrderCalcMargin(orderType, _Symbol, lotSize, openPrice, marginRequired))
    {
        Print(logMessage + "ERROR: Failed to calculate margin requirements");
        return;
    }
    
    logMessage += StringFormat("Margin Required: %.2f\n", marginRequired);
    
    if(marginRequired > freeMargin)
    {
        logMessage += StringFormat("ERROR: Insufficient margin. Required: %.2f Available: %.2f\n", 
                                 marginRequired, freeMargin);
        Print(logMessage);
        return;
    }
    
    // –ï—Å–ª–∏ —Ä–∞–∑–º–µ—Ä –ª–æ—Ç–∞ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º—ã–π –¥–ª—è –æ–¥–Ω–æ–π —Å–¥–µ–ª–∫–∏
    const double MAX_SINGLE_LOT = 1000000000.0;
    if(lotSize > MAX_SINGLE_LOT)
    {
        logMessage += StringFormat("Large lot size detected (%.2f). Splitting into multiple positions.\n", lotSize);
        Print(logMessage);
        OpenMultiplePositions(orderType, lotSize, openPrice, stopLoss, takeProfit);
        return;
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Ç—Ä–µ–π–ª–∏–Ω–≥ —Å—Ç–æ–ø–∞
if(TrailingStopCoef <= 0)
{
    CurrentTrailingStop = 0;
    CurrentTrailingStart = 0;
}
else
{
    // –ö–∞–∫ —Ä–∞–∑–º–µ—Ä trailing stop, —Ç–∞–∫ –∏ —Ç–æ—á–∫–∞ –µ–≥–æ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –∑–∞–≤–∏—Å—è—Ç –æ—Ç –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞
    CurrentTrailingStop = (int)(StopLoss * TrailingStopCoef);
    CurrentTrailingStart = (int)(StopLoss * TrailingStopCoef);
}
    
    // –û—Ç–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏
    trade.SetDeviationInPoints(5);
    
    logMessage += "Attempting to open position...\n";
    Print(logMessage);
    
    if(!trade.PositionOpen(_Symbol, orderType, lotSize, openPrice, stopLoss, takeProfit, "EMA + RSI Expert"))
    {
        Print("ERROR opening position: ", GetLastError());
        return;
    }
    
    if(trade.ResultRetcode() == TRADE_RETCODE_DONE)
    {
        initialTradePrice = openPrice;
        isTrailingOrderPlaced = false;
        
        Print("Position opened successfully:",
              "\nTicket: ", trade.ResultOrder(),
              "\nLot: ", lotSize,
              "\nPrice: ", openPrice,
              "\nSL: ", stopLoss,
              "\nTP: ", takeProfit,
              "\nTrailing Stop: ", CurrentTrailingStop,
              "\nTrailing Start: ", CurrentTrailingStart);
    }
}

//+------------------------------------------------------------------+
//| –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π                                               |
//+------------------------------------------------------------------+
bool UpdateNews()
{
    datetime currentTime = TimeCurrent();
    nextNewsUpdate = currentTime + UpdateHours * 3600;
    
    // –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∫ –æ–±—â–µ–π –ø–∞–ø–∫–µ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
    string terminal_data_path = TerminalInfoString(TERMINAL_COMMONDATA_PATH);
    string mql_files_dir = terminal_data_path + "\\MQL5\\Files\\";
    
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–æ–π —Ñ–∞–π–ª –Ω–æ–≤–æ—Å—Ç–µ–π –Ω–∞–º –Ω—É–∂–µ–Ω
    MqlDateTime dt;
    TimeToStruct(currentTime, dt);
    string requiredFile = StringFormat("news_%04d%02d.txt", dt.year, dt.mon);
    string fullPath = mql_files_dir + requiredFile;
    
    // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —Ñ–∞–π–ª —É–∂–µ –∑–∞–≥—Ä—É–∂–µ–Ω, –Ω–µ –∑–∞–≥—Ä—É–∂–∞–µ–º –µ–≥–æ —Å–Ω–æ–≤–∞
    if(requiredFile == currentNewsFile)
        return true;
        
    // –û—á–∏—â–∞–µ–º —Ç–µ–∫—É—â–∏–π –º–∞—Å—Å–∏–≤ –Ω–æ–≤–æ—Å—Ç–µ–π
    ArrayFree(news);
    newsCount = 0;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–∞
    if(!FileIsExist(requiredFile, FILE_COMMON))
    {
        string warningMessage = StringFormat(
            "\n=== NEWS FILE NOT FOUND ===\n" +
            "Date (UTC): %s\n" +
            "User: %s\n" +
            "Missing file: %s\n" +
            "Expected location: %s\n" +
            "WARNING: Expert will continue running without news filter!\n" +
            "=========================",
            TimeToString(TimeGMT(), TIME_DATE|TIME_SECONDS),
            AccountInfoString(ACCOUNT_NAME),
            requiredFile,
            fullPath
        );
        Print(warningMessage);
        return true; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º true, —á—Ç–æ–±—ã —Å–æ–≤–µ—Ç–Ω–∏–∫ –ø—Ä–æ–¥–æ–ª–∂–∏–ª —Ä–∞–±–æ—Ç—É
    }
    
    // –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª
    int fileHandle = FileOpen(requiredFile, FILE_READ|FILE_TXT|FILE_ANSI|FILE_COMMON);
    if(fileHandle == INVALID_HANDLE)
    {
        string warningMessage = StringFormat(
            "\n=== ERROR OPENING NEWS FILE ===\n" +
            "Date (UTC): %s\n" +
            "User: %s\n" +
            "File: %s\n" +
            "Error code: %d\n" +
            "WARNING: Expert will continue running without news filter!\n" +
            "==============================",
            TimeToString(TimeGMT(), TIME_DATE|TIME_SECONDS),
            AccountInfoString(ACCOUNT_NAME),
            requiredFile,
            GetLastError()
        );
        Print(warningMessage);
        return true; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º true, —á—Ç–æ–±—ã —Å–æ–≤–µ—Ç–Ω–∏–∫ –ø—Ä–æ–¥–æ–ª–∂–∏–ª —Ä–∞–±–æ—Ç—É
    }
    
    // –ß–∏—Ç–∞–µ–º —Ñ–∞–π–ª –ø–æ—Å—Ç—Ä–æ—á–Ω–æ
    SNewsEvent testNews;
    while(!FileIsEnding(fileHandle))
    {
        string line = FileReadString(fileHandle);
        
        // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—É—Å—Ç—ã–µ —Å—Ç—Ä–æ–∫–∏
        if(StringLen(line) == 0)
            continue;
            
        // –ï—Å–ª–∏ —ç—Ç–æ —Å—Ç—Ä–æ–∫–∞ —Å –¥–∞—Ç–æ–π
        if(StringFind(line, "testNews.time") >= 0)
        {
            // –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞—Ç—É
            int pos1 = StringFind(line, "\"") + 1;
            int pos2 = StringFind(line, "\"", pos1);
            string dateTimeStr = StringSubstr(line, pos1, pos2-pos1);
            testNews.time = StringToTime(dateTimeStr);
            
            // –ß–∏—Ç–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–µ —Å—Ç—Ä–æ–∫–∏
            line = FileReadString(fileHandle); // currency
            pos1 = StringFind(line, "\"") + 1;
            pos2 = StringFind(line, "\"", pos1);
            testNews.currency = StringSubstr(line, pos1, pos2-pos1);
            
            line = FileReadString(fileHandle); // title
            pos1 = StringFind(line, "\"") + 1;
            pos2 = StringFind(line, "\"", pos1);
            testNews.title = StringSubstr(line, pos1, pos2-pos1);
            
            line = FileReadString(fileHandle); // impact
            pos1 = StringFind(line, "\"") + 1;
            pos2 = StringFind(line, "\"", pos1);
            testNews.impact = StringSubstr(line, pos1, pos2-pos1);
            
            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–æ–∫—É AddNewsEvent
            line = FileReadString(fileHandle);
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤–æ—Å—Ç—å –≤ –º–∞—Å—Å–∏–≤
            AddNewsEvent(testNews);
        }
    }
    
    FileClose(fileHandle);
    
    if(newsCount == 0)
    {
        string warningMessage = StringFormat(
            "\n=== NO NEWS EVENTS FOUND ===\n" +
            "Date (UTC): %s\n" +
            "User: %s\n" +
            "File: %s\n" +
            "WARNING: Expert will continue running without news filter!\n" +
            "==========================",
            TimeToString(TimeGMT(), TIME_DATE|TIME_SECONDS),
            AccountInfoString(ACCOUNT_NAME),
            requiredFile
        );
        Print(warningMessage);
        return true; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º true, —á—Ç–æ–±—ã —Å–æ–≤–µ—Ç–Ω–∏–∫ –ø—Ä–æ–¥–æ–ª–∂–∏–ª —Ä–∞–±–æ—Ç—É
    }
    
    currentNewsFile = requiredFile;
    Print("Successfully loaded ", newsCount, " news events from file: ", requiredFile);
    return true;
}

//+------------------------------------------------------------------+
//| –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–∏ –≤ –º–∞—Å—Å–∏–≤                                       |
//+------------------------------------------------------------------+
void AddNewsEvent(SNewsEvent &newEvent)
{
    newsCount++;
    ArrayResize(news, newsCount);
    news[newsCount-1] = newEvent;
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–≤–æ—Å—Ç–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏                                       |
//+------------------------------------------------------------------+
bool IsNewsTime()
{
    if(ArraySize(news) == 0)
        return false;
        
    datetime currentTime = TimeCurrent();
    
    for(int i = 0; i < ArraySize(news); i++)
    {
        if(news[i].time > currentTime - 24*60*60) // –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–æ–≤–æ—Å—Ç–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞
        {
            int minutesDiff = (int)(news[i].time - currentTime) / 60;
            bool isNewsApproaching = false;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è USD
            if(StringFind(_Symbol, "USD") >= 0 && UseUSDFilter)
            {
                if(!CheckNewsImpact(news[i].impact, "USD"))
                    continue;
                    
                if(MathAbs(minutesDiff) <= USD_MinutesBefore || 
                   (minutesDiff < 0 && MathAbs(minutesDiff) <= USD_MinutesAfter))
                {
                    isNewsApproaching = true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è USD
            if(StringFind(_Symbol, "GBP") >= 0 && UseGBPFilter)
            {
                if(!CheckNewsImpact(news[i].impact, "GBP"))
                    continue;
                    
                if(MathAbs(minutesDiff) <= GBP_MinutesBefore || 
                   (minutesDiff < 0 && MathAbs(minutesDiff) <= GBP_MinutesAfter))
                {
                    isNewsApproaching = true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è EUR
            if(StringFind(_Symbol, "EUR") >= 0 && UseEURFilter)
            {
                if(!CheckNewsImpact(news[i].impact, "EUR"))
                    continue;
                    
                if(MathAbs(minutesDiff) <= EUR_MinutesBefore || 
                   (minutesDiff < 0 && MathAbs(minutesDiff) <= EUR_MinutesAfter))
                {
                    isNewsApproaching = true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è JPY
            if(StringFind(_Symbol, "JPY") >= 0 && UseJPYFilter)
            {
                if(!CheckNewsImpact(news[i].impact, "JPY"))
                    continue;
                    
                if(MathAbs(minutesDiff) <= JPY_MinutesBefore || 
                   (minutesDiff < 0 && MathAbs(minutesDiff) <= JPY_MinutesAfter))
                {
                    isNewsApproaching = true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è CHF
            if(StringFind(_Symbol, "CHF") >= 0 && UseCHFFilter)
            {
                if(!CheckNewsImpact(news[i].impact, "CHF"))
                    continue;
                    
                if(MathAbs(minutesDiff) <= CHF_MinutesBefore || 
                   (minutesDiff < 0 && MathAbs(minutesDiff) <= CHF_MinutesAfter))
                {
                    isNewsApproaching = true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è AUD
            if(StringFind(_Symbol, "AUD") >= 0 && UseAUDFilter)
            {
                if(!CheckNewsImpact(news[i].impact, "AUD"))
                    continue;
                    
                if(MathAbs(minutesDiff) <= AUD_MinutesBefore || 
                   (minutesDiff < 0 && MathAbs(minutesDiff) <= AUD_MinutesAfter))
                {
                    isNewsApproaching = true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è CAD
            if(StringFind(_Symbol, "CAD") >= 0 && UseCADFilter)
            {
                if(!CheckNewsImpact(news[i].impact, "CAD"))
                    continue;
                    
                if(MathAbs(minutesDiff) <= CAD_MinutesBefore || 
                   (minutesDiff < 0 && MathAbs(minutesDiff) <= CAD_MinutesAfter))
                {
                    isNewsApproaching = true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è NZD
            if(StringFind(_Symbol, "NZD") >= 0 && UseNZDFilter)
            {
                if(!CheckNewsImpact(news[i].impact, "NZD"))
                    continue;
                    
                if(MathAbs(minutesDiff) <= NZD_MinutesBefore || 
                   (minutesDiff < 0 && MathAbs(minutesDiff) <= NZD_MinutesAfter))
                {
                    isNewsApproaching = true;
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è CNY
            if(StringFind(_Symbol, "CNY") >= 0 && UseCNYFilter)
            {
                if(!CheckNewsImpact(news[i].impact, "CNY"))
                    continue;
                    
                if(MathAbs(minutesDiff) <= CNY_MinutesBefore || 
                   (minutesDiff < 0 && MathAbs(minutesDiff) <= CNY_MinutesAfter))
                {
                    isNewsApproaching = true;
                }
            }

            // –ï—Å–ª–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –ø—Ä–∏–±–ª–∏–∂–∞—é—â–∞—è—Å—è –Ω–æ–≤–æ—Å—Ç—å, –ø—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            if(isNewsApproaching)
            {
                for(int pos = PositionsTotal() - 1; pos >= 0; pos--)
                {
                    ulong ticket = PositionGetTicket(pos);
                    if(PositionSelectByTicket(ticket))
                    {
                        if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
                           PositionGetInteger(POSITION_MAGIC) == 123456)
                        {
                            double positionProfit = PositionGetDouble(POSITION_PROFIT);
                            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                            double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
                            double currentSL = PositionGetDouble(POSITION_SL);
                            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                            
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –ø–æ–∑–∏—Ü–∏—è –≤ –ø–ª—é—Å–µ
                            bool isInProfit = false;
                            if(posType == POSITION_TYPE_BUY)
                                isInProfit = (currentPrice > openPrice);
                            else
                                isInProfit = (currentPrice < openPrice);
                            
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–µ–Ω –ª–∏ trailing stop
                            bool isTrailingActive = false;
                            if(posType == POSITION_TYPE_BUY)
                                isTrailingActive = (currentPrice - openPrice) > CurrentTrailingStart * _Point;
                            else
                                isTrailingActive = (openPrice - currentPrice) > CurrentTrailingStart * _Point;
                            
                            // –ï—Å–ª–∏ –≤ –ø–ª—é—Å–µ –∏ trailing stop –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω
if(isInProfit && !isTrailingActive && UseNewsProtectionPlus)
{
    double newSL = posType == POSITION_TYPE_BUY ? 
                 openPrice + NewsProtectionPlusPoints * _Point :
                 openPrice - NewsProtectionPlusPoints * _Point;
                 
    if((posType == POSITION_TYPE_BUY && (newSL > currentSL || currentSL == 0)) ||
       (posType == POSITION_TYPE_SELL && (newSL < currentSL || currentSL == 0)))
    {
        trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
        Print("News protection: Modified SL to breakeven +", NewsProtectionPlusPoints, " points");
    }
}
// –ï—Å–ª–∏ –≤ –º–∏–Ω—É—Å–µ
else if(!isInProfit && UseNewsProtectionPlus)
{
    double newTP = openPrice + (posType == POSITION_TYPE_BUY ? 
                 NewsProtectionPlusPoints * _Point : 
                 -NewsProtectionPlusPoints * _Point);
                 
    trade.PositionModify(ticket, PositionGetDouble(POSITION_SL), newTP);
    Print("News protection: Modified TP to breakeven +", NewsProtectionPlusPoints, " points");
}
                        }
                    }
                }
                return true;
            }
        }
    }
    
    return false;
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∞–∂–Ω–æ—Å—Ç–∏ –Ω–æ–≤–æ—Å—Ç–∏                                         |
//+------------------------------------------------------------------+
bool CheckNewsImpact(string impact, string currency)
{
    if(currency == "USD")
    {
        if(impact == "Non-Economic" && !USD_NonEconomic) return false;
        if(impact == "Low" && !USD_Low) return false;
        if(impact == "Medium" && !USD_Medium) return false;
        if(impact == "High" && !USD_High) return false;
    }
    else if(currency == "EUR")
    {
        if(impact == "Non-Economic" && !EUR_NonEconomic) return false;
        if(impact == "Low" && !EUR_Low) return false;
        if(impact == "Medium" && !EUR_Medium) return false;
        if(impact == "High" && !EUR_High) return false;
    }
    else if(currency == "GBP")
    {
        if(impact == "Non-Economic" && !GBP_NonEconomic) return false;
        if(impact == "Low" && !GBP_Low) return false;
        if(impact == "Medium" && !GBP_Medium) return false;
        if(impact == "High" && !GBP_High) return false;
    }
    else if(currency == "JPY")
    {
        if(impact == "Non-Economic" && !JPY_NonEconomic) return false;
        if(impact == "Low" && !JPY_Low) return false;
        if(impact == "Medium" && !JPY_Medium) return false;
        if(impact == "High" && !JPY_High) return false;
    }
    else if(currency == "CHF")
    {
        if(impact == "Non-Economic" && !CHF_NonEconomic) return false;
        if(impact == "Low" && !CHF_Low) return false;
        if(impact == "Medium" && !CHF_Medium) return false;
        if(impact == "High" && !CHF_High) return false;
    }
    else if(currency == "AUD")
    {
        if(impact == "Non-Economic" && !AUD_NonEconomic) return false;
        if(impact == "Low" && !AUD_Low) return false;
        if(impact == "Medium" && !AUD_Medium) return false;
        if(impact == "High" && !AUD_High) return false;
    }
    else if(currency == "CAD")
    {
        if(impact == "Non-Economic" && !CAD_NonEconomic) return false;
        if(impact == "Low" && !CAD_Low) return false;
        if(impact == "Medium" && !CAD_Medium) return false;
        if(impact == "High" && !CAD_High) return false;
    }
    else if(currency == "NZD")
    {
        if(impact == "Non-Economic" && !NZD_NonEconomic) return false;
        if(impact == "Low" && !NZD_Low) return false;
        if(impact == "Medium" && !NZD_Medium) return false;
        if(impact == "High" && !NZD_High) return false;
    }
    else if(currency == "CNY")
    {
        if(impact == "Non-Economic" && !CNY_NonEconomic) return false;
        if(impact == "Low" && !CNY_Low) return false;
        if(impact == "Medium" && !CNY_Medium) return false;
        if(impact == "High" && !CNY_High) return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π –Ω–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å                         |
//+------------------------------------------------------------------+
bool HasNewsForCurrentDay()
{
    datetime currentTime = TimeCurrent();
    MqlDateTime current;
    TimeToStruct(currentTime, current);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω–∞ –ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–≤–æ—Å—Ç–µ–π –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –¥–Ω—è –Ω–µ–¥–µ–ª–∏
    bool checkNewsToday = false;
    switch(current.day_of_week)
    {
        case MONDAY:
            checkNewsToday = Monday_CheckNews;
            break;
        case TUESDAY:
            checkNewsToday = Tuesday_CheckNews;
            break;
        case WEDNESDAY:
            checkNewsToday = Wednesday_CheckNews;
            break;
        case THURSDAY:
            checkNewsToday = Thursday_CheckNews;
            break;
        case FRIDAY:
            checkNewsToday = Friday_CheckNews;
            break;
        default:
            Print("Weekend - trading disabled");
            return false;
    }
    
    // –ï—Å–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–æ–≤–æ—Å—Ç–µ–π –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –¥–Ω—è –æ—Ç–∫–ª—é—á–µ–Ω–∞, —Ä–∞–∑—Ä–µ—à–∞–µ–º —Ç–æ—Ä–≥–æ–≤–ª—é
    if(!checkNewsToday)
    {
        return true;
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü —Ç–µ–∫—É—â–µ–≥–æ –¥–Ω—è
    datetime dayStart = StringToTime(StringFormat("%04d.%02d.%02d 00:00:00", 
        current.year, current.mon, current.day));
    datetime dayEnd = StringToTime(StringFormat("%04d.%02d.%02d 23:59:59", 
        current.year, current.mon, current.day));
    
    bool hasImportantNews = false;
    string newsFoundForCurrencies = "";  // –°—Ç—Ä–æ–∫–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤–∞–ª—é—Ç, –ø–æ –∫–æ—Ç–æ—Ä—ã–º –Ω–∞–π–¥–µ–Ω—ã –Ω–æ–≤–æ—Å—Ç–∏
    int currencyCount = 0;              // –°—á–µ—Ç—á–∏–∫ –≤–∞–ª—é—Ç —Å –Ω–æ–≤–æ—Å—Ç—è–º–∏
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é –Ω–æ–≤–æ—Å—Ç—å –≤ –º–∞—Å—Å–∏–≤–µ
    for(int i = 0; i < ArraySize(news); i++)
    {
        // –ï—Å–ª–∏ –Ω–æ–≤–æ—Å—Ç—å –ø–æ–ø–∞–¥–∞–µ—Ç –≤ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        if(news[i].time >= dayStart && news[i].time <= dayEnd)
        {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤–∫–ª—é—á–µ–Ω –ª–∏ —Ñ–∏–ª—å—Ç—Ä –¥–ª—è –≤–∞–ª—é—Ç—ã –Ω–æ–≤–æ—Å—Ç–∏
            bool isNewsImportant = false;
            
            if(news[i].currency == "AUD" && FilterAUD && StringFind(newsFoundForCurrencies, "AUD") < 0) 
            {
                isNewsImportant = true;
                newsFoundForCurrencies += "AUD,";
                currencyCount++;
            }
            else if(news[i].currency == "CAD" && FilterCAD && StringFind(newsFoundForCurrencies, "CAD") < 0)
            {
                isNewsImportant = true;
                newsFoundForCurrencies += "CAD,";
                currencyCount++;
            }
            else if(news[i].currency == "CHF" && FilterCHF && StringFind(newsFoundForCurrencies, "CHF") < 0)
            {
                isNewsImportant = true;
                newsFoundForCurrencies += "CHF,";
                currencyCount++;
            }
            else if(news[i].currency == "CNY" && FilterCNY && StringFind(newsFoundForCurrencies, "CNY") < 0)
            {
                isNewsImportant = true;
                newsFoundForCurrencies += "CNY,";
                currencyCount++;
            }
            else if(news[i].currency == "EUR" && FilterEUR && StringFind(newsFoundForCurrencies, "EUR") < 0)
            {
                isNewsImportant = true;
                newsFoundForCurrencies += "EUR,";
                currencyCount++;
            }
            else if(news[i].currency == "GBP" && FilterGBP && StringFind(newsFoundForCurrencies, "GBP") < 0)
            {
                isNewsImportant = true;
                newsFoundForCurrencies += "GBP,";
                currencyCount++;
            }
            else if(news[i].currency == "JPY" && FilterJPY && StringFind(newsFoundForCurrencies, "JPY") < 0)
            {
                isNewsImportant = true;
                newsFoundForCurrencies += "JPY,";
                currencyCount++;
            }
            else if(news[i].currency == "NZD" && FilterNZD && StringFind(newsFoundForCurrencies, "NZD") < 0)
            {
                isNewsImportant = true;
                newsFoundForCurrencies += "NZD,";
                currencyCount++;
            }
            else if(news[i].currency == "USD" && FilterUSD && StringFind(newsFoundForCurrencies, "USD") < 0)
            {
                isNewsImportant = true;
                newsFoundForCurrencies += "USD,";
                currencyCount++;
            }
            
            if(isNewsImportant)
            {
                hasImportantNews = true;
                Print("Important news found for ", news[i].currency, " on ", 
                      TimeToString(news[i].time, TIME_DATE), ": ", news[i].title);
            }
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
    if(hasImportantNews)
    {
        // –ï—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –æ–¥–Ω—É –≤–∞–ª—é—Ç—É –∏ –Ω–æ–≤–æ—Å—Ç–∏ —Ç–æ–ª—å–∫–æ –ø–æ –æ–¥–Ω–æ–π –≤–∞–ª—é—Ç–µ
        if(Check_Single_Currency_News && currencyCount == 1)
        {
            Print("Only single currency news found (", newsFoundForCurrencies, ") for day (", 
                  TimeToString(currentTime, TIME_DATE), "). Trading disabled.");
            return false;
        }
        
        Print("Multiple currency news found (", newsFoundForCurrencies, ") for day (", 
              TimeToString(currentTime, TIME_DATE), "). Trading enabled.");
        return true;
    }
    
    Print("No important news found for current day (", 
          TimeToString(currentTime, TIME_DATE), 
          "). Trading disabled.");
    return false;
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏                                        |
//+------------------------------------------------------------------+
bool IsTradeTime()
{
    if(IsMidDayBreak())
        return false;
        
    MqlDateTime dt;
    TimeToStruct(TimeCurrent(), dt);
    
    ENUM_TRADE_HOURS startHour, endHour;
    bool isDayEnabled;
    
    switch(dt.day_of_week)
    {
        case MONDAY:
            isDayEnabled = Monday_Enabled;
            startHour = Monday_StartHour;
            endHour = Monday_EndHour;
            break;
        case TUESDAY:
            isDayEnabled = Tuesday_Enabled;
            startHour = Tuesday_StartHour;
            endHour = Tuesday_EndHour;
            break;
        case WEDNESDAY:
            isDayEnabled = Wednesday_Enabled;
            startHour = Wednesday_StartHour;
            endHour = Wednesday_EndHour;
            break;
        case THURSDAY:
            isDayEnabled = Thursday_Enabled;
            startHour = Thursday_StartHour;
            endHour = Thursday_EndHour;
            break;
        case FRIDAY:
            isDayEnabled = Friday_Enabled;
            startHour = Friday_StartHour;
            endHour = Friday_EndHour;
            break;
        default:
            return false;
    }
    
    if(!isDayEnabled)
        return false;
        
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –≤ —á–∞—Å—ã
    int currentHour = dt.hour;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ —Ç–µ–∫—É—â–∏–π —á–∞—Å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ —Ç–æ—Ä–≥–æ–≤—ã—Ö —á–∞—Å–æ–≤
    if(endHour >= startHour)
    {
        return (currentHour >= startHour && currentHour < endHour);
    }
    else // –ï—Å–ª–∏ –∫–æ–Ω–µ—Ü —Ç–æ—Ä–≥–æ–≤–ª–∏ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å
    {
        return (currentHour >= startHour || currentHour < endHour);
    }
}

//+------------------------------------------------------------------+
//| –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ trailing stop                                          |
//+------------------------------------------------------------------+
void UpdateTrailingStop()
{
    for(int i = PositionsTotal() - 1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(PositionSelectByTicket(ticket))
        {
            if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
               PositionGetInteger(POSITION_MAGIC) == 123456)
            {
                double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
                double currentSL = PositionGetDouble(POSITION_SL);
                ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –¥–æ—Å—Ç–∏–≥–Ω—É—Ç–∞ –ª–∏ —Ç–æ—á–∫–∞ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ trailing stop
                bool shouldTrail = false;
                if(posType == POSITION_TYPE_BUY)
                {
                    shouldTrail = (currentPrice - openPrice) >= CurrentTrailingStart * _Point;
                    if(shouldTrail)
                    {
                        double newSL = currentPrice - CurrentTrailingStop * _Point;
                        if(newSL > currentSL)
                        {
                            trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
                            Print("Trailing Stop updated for Buy position. New SL: ", newSL);
                        }
                    }
                }
                else // POSITION_TYPE_SELL
                {
                    shouldTrail = (openPrice - currentPrice) >= CurrentTrailingStart * _Point;
                    if(shouldTrail)
                    {
                        double newSL = currentPrice + CurrentTrailingStop * _Point;
                        if(newSL < currentSL || currentSL == 0)
                        {
                            trade.PositionModify(ticket, newSL, PositionGetDouble(POSITION_TP));
                            Print("Trailing Stop updated for Sell position. New SL: ", newSL);
                        }
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ trailing order                              |
//+------------------------------------------------------------------+
void CheckTrailingOrder()
{
    static datetime lastTrailingOrderTime = 0;
    datetime currentTime = TimeCurrent();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º trailing order –Ω–µ —á–∞—â–µ —á–µ–º —Ä–∞–∑ –≤ –º–∏–Ω—É—Ç—É
    if(currentTime - lastTrailingOrderTime < 60)
        return;
        
    lastTrailingOrderTime = currentTime;
    
    if(!isTrailingOrderPlaced)
    {
        // –ï—Å–ª–∏ –Ω–µ—Ç –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π, –Ω–µ —Ä–∞–∑–º–µ—â–∞–µ–º trailing order
        if(PositionsTotal() == 0)
            return;
            
        for(int i = PositionsTotal() - 1; i >= 0; i--)
        {
            ulong ticket = PositionGetTicket(i);
            if(PositionSelectByTicket(ticket))
            {
                if(PositionGetString(POSITION_SYMBOL) == _Symbol && 
                   PositionGetInteger(POSITION_MAGIC) == 123456)
                {
                    double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
                    double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
                    ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
                    double lotSize = PositionGetDouble(POSITION_VOLUME);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è trailing order
                    if(posType == POSITION_TYPE_BUY && 
                       currentPrice - openPrice >= TrailingOrderDistance * _Point)
                    {
                        double sellPrice = currentPrice - TrailingOrderDistance * _Point;
                        trade.SellStop(lotSize, sellPrice, _Symbol, 0, 0, 0, 0, "Trailing Order");
                        isTrailingOrderPlaced = true;
                        trailingOrderLot = lotSize;
                        Print("Placed trailing sell stop order at ", sellPrice);
                    }
                    else if(posType == POSITION_TYPE_SELL && 
                            openPrice - currentPrice >= TrailingOrderDistance * _Point)
                    {
                        double buyPrice = currentPrice + TrailingOrderDistance * _Point;
                        trade.BuyStop(lotSize, buyPrice, _Symbol, 0, 0, 0, 0, "Trailing Order");
                        isTrailingOrderPlaced = true;
                        trailingOrderLot = lotSize;
                        Print("Placed trailing buy stop order at ", buyPrice);
                    }
                }
            }
        }
    }
}

//+------------------------------------------------------------------+
//| –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –Ω–æ–≤–æ—Å—Ç—è—Ö                      |
//+------------------------------------------------------------------+
void UpdateNewsDisplay()
{
    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –º–µ—Ç–∫–∏
    DeleteNewsLabels();
    
    if(ArraySize(news) == 0)
        return;
        
    datetime currentTime = TimeCurrent();
    int displayedNews = 0;
    
    for(int i = 0; i < ArraySize(news); i++)
    {
        if(news[i].time < currentTime - 24*60*60) // –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å—Ç–∞—Ä—ã–µ –Ω–æ–≤–æ—Å—Ç–∏
            continue;
            
        // –°–æ–∑–¥–∞–µ–º –º–µ—Ç–∫—É –¥–ª—è –Ω–æ–≤–æ—Å—Ç–∏
        string labelName = newsLabelBase + IntegerToString(displayedNews);
        string labelText = TimeToString(news[i].time, TIME_DATE|TIME_MINUTES) + 
                          " " + news[i].currency + " " + 
                          news[i].title + " (" + news[i].impact + ")";
                          
        ObjectCreate(0, labelName, OBJ_LABEL, 0, 0, 0);
        ObjectSetString(0, labelName, OBJPROP_TEXT, labelText);
        ObjectSetInteger(0, labelName, OBJPROP_COLOR, NewsTextColor);
        ObjectSetInteger(0, labelName, OBJPROP_CORNER, CORNER_RIGHT_UPPER);
        ObjectSetInteger(0, labelName, OBJPROP_XDISTANCE, 10);
        ObjectSetInteger(0, labelName, OBJPROP_YDISTANCE, 20 + displayedNews * 20);
        
        displayedNews++;
        if(displayedNews >= 5) // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º—É–º 5 –±–ª–∏–∂–∞–π—à–∏—Ö –Ω–æ–≤–æ—Å—Ç–µ–π
            break;
    }
    
    newsLabelsCount = displayedNews;
}

//+------------------------------------------------------------------+
//| –£–¥–∞–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫ –æ –Ω–æ–≤–æ—Å—Ç—è—Ö                          |
//+------------------------------------------------------------------+
void DeleteNewsLabels()
{
    for(int i = 0; i < newsLabelsCount; i++)
    {
        string labelName = newsLabelBase + IntegerToString(i);
        ObjectDelete(0, labelName);
    }
    newsLabelsCount = 0;
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ—Ä–≥–æ–≤—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤                                      |
//+------------------------------------------------------------------+
bool CheckTradeParameters()
{
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –ø–µ—Ä–µ—Ä—ã–≤–∞
    if(UseMidDayBreak)
    {
        if(!CheckTimeString(MidDayBreakStart) || !CheckTimeString(MidDayBreakEnd))
        {
            Print("Invalid mid-day break time format");
            return false;
        }
    }
        
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –ª–æ—Ç–∞
    if(UseFixedLot && (FixedLotSize <= 0 || 
       FixedLotSize < SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN) ||
       FixedLotSize > SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX)))
    {
        Print("Invalid fixed lot size");
        return false;
    }
    
    if(LotReductionPercent < 0 || LotReductionPercent > 100)
    {
        Print("Invalid lot reduction percentage. Must be between 0 and 100");
        return false;
    }
    
    return true;
}

//+------------------------------------------------------------------+
//| –û—Ç–∫—Ä—ã—Ç–∏–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø–æ–∑–∏—Ü–∏–π —Å —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º –±–æ–ª—å—à–æ–≥–æ –ª–æ—Ç–∞           |
//+------------------------------------------------------------------+
void OpenMultiplePositions(ENUM_ORDER_TYPE orderType, double totalLotSize, double price, double sl, double tp)
{
    const double MAX_LOT_SIZE = 1000000.0;  // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ –ª–æ—Ç–∞
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –º–∞—Ä–∂–∏ –ø–µ—Ä–µ–¥ –æ—Ç–∫—Ä—ã—Ç–∏–µ–º –ø–æ–∑–∏—Ü–∏–π
    double marginRequired = 0.0;
    if(!OrderCalcMargin(orderType, _Symbol, totalLotSize, price, marginRequired))
    {
        Print("Failed to calculate margin requirements. Error: ", GetLastError());
        return;
    }
    
    double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
    
    Print("=== MARGIN CHECK ===");
    Print("Total lots requested: ", totalLotSize);
    Print("Margin required: ", marginRequired);
    Print("Free margin: ", freeMargin);
    
    // –ï—Å–ª–∏ —Ç—Ä–µ–±—É–µ–º–∞—è –º–∞—Ä–∂–∞ –±–æ–ª—å—à–µ —Å–≤–æ–±–æ–¥–Ω–æ–π, –∫–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏
    if(marginRequired > freeMargin)
    {
        double maxPossibleLots = (freeMargin / marginRequired) * totalLotSize * 0.95; // 95% –æ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ
        maxPossibleLots = NormalizeDouble(maxPossibleLots, 2);
        
        Print("WARNING: Insufficient margin for requested position size");
        Print("Adjusting total lot size from ", totalLotSize, " to ", maxPossibleLots);
        
        totalLotSize = maxPossibleLots;
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    if(totalLotSize < minLot)
    {
        Print("Calculated lot size too small. Minimum allowed: ", minLot);
        return;
    }
    
    // –û—Ç–∫—Ä—ã–≤–∞–µ–º –ø–µ—Ä–≤—É—é –ø–æ–∑–∏—Ü–∏—é
    double firstLot = MathMin(MAX_LOT_SIZE, totalLotSize);
    
    Print("=== OPENING FIRST POSITION ===");
    Print("Lot size: ", firstLot);
    Print("Price: ", price);
    Print("SL: ", sl);
    Print("TP: ", tp);
    
    if(!trade.PositionOpen(_Symbol, orderType, firstLot, price, sl, tp, "EMA + RSI Expert Main"))
    {
        Print("Failed to open initial position. Error: ", GetLastError());
        return;
    }
    
    // –ï—Å–ª–∏ –æ—Å—Ç–∞–ª—Å—è –æ–±—ä–µ–º –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π
    if(totalLotSize > MAX_LOT_SIZE)
    {
        double remainingLots = totalLotSize - MAX_LOT_SIZE;
        int additionalOrders = (int)MathCeil(remainingLots / MAX_LOT_SIZE);
        
        Print("=== OPENING ADDITIONAL POSITIONS ===");
        Print("Remaining lots: ", remainingLots);
        Print("Additional orders needed: ", additionalOrders);
        
        for(int i = 0; i < additionalOrders; i++)
        {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∞—Ä–∂—É –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º –Ω–æ–≤—ã–º –æ—Ä–¥–µ—Ä–æ–º
            freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
            double currentLot = (i == additionalOrders - 1) ? 
                              NormalizeDouble(remainingLots, 2) : MAX_LOT_SIZE;
            
            if(!OrderCalcMargin(orderType, _Symbol, currentLot, price, marginRequired))
                continue;
                
            if(marginRequired > freeMargin)
            {
                Print("WARNING: Insufficient margin for additional order. Stopping.");
                break;
            }
            
            if(currentLot > MAX_LOT_SIZE)
                currentLot = MAX_LOT_SIZE;
                
            remainingLots -= currentLot;
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –æ—Ç—Å—Ç—É–ø –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ—Ä–¥–µ—Ä–∞
            double orderPrice;
            if(orderType == ORDER_TYPE_BUY)
            {
                orderPrice = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + ((5 + i) * _Point);
                if(!trade.BuyStop(currentLot, orderPrice, _Symbol, sl, tp, 
                   ORDER_TIME_GTC, 0, "EMA + RSI Expert " + IntegerToString(i+2)))
                {
                    Print("Failed to place buy stop order ", i+2, ". Error: ", GetLastError());
                    continue;
                }
            }
            else
            {
                orderPrice = SymbolInfoDouble(_Symbol, SYMBOL_BID) - ((5 + i) * _Point);
                if(!trade.SellStop(currentLot, orderPrice, _Symbol, sl, tp, 
                   ORDER_TIME_GTC, 0, "EMA + RSI Expert " + IntegerToString(i+2)))
                {
                    Print("Failed to place sell stop order ", i+2, ". Error: ", GetLastError());
                    continue;
                }
            }
            
            Sleep(500); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑–∞–¥–µ—Ä–∂–∫—É –º–µ–∂–¥—É –æ—Ä–¥–µ—Ä–∞–º–∏
        }
    }
}

//+------------------------------------------------------------------+
//| –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ —Ñ–æ—Ä–º–∞—Ç–∞ –≤—Ä–µ–º–µ–Ω–∏                             |
//+------------------------------------------------------------------+
bool CheckTimeString(string timeStr)
{
    string parts[];
    if(StringSplit(timeStr, ':', parts) != 2)
        return false;
        
    int hours = (int)StringToInteger(parts[0]);
    int minutes = (int)StringToInteger(parts[1]);
    
    return (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60);
}
//+------------------------------------------------------------------+
